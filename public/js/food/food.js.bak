document.addEventListener('DOMContentLoaded', () => {
    const ingredientsList = document.getElementById('ingredients-list');
    const createRecipeForm = document.getElementById('create-recipe-form');
    const recipeNameInput = document.getElementById('recipeName');
    const createRecipeStatus = document.getElementById('create-recipe-status');
    const recipeListContainer = document.getElementById('recipe-list');
    const recipesDisplayStatus = document.getElementById('recipes-display-status');

    // Initialize Cronometer text parser for all existing ingredient items
    if (typeof initializeCronometerTextParser === 'function') {
        console.log('Initializing Cronometer text parser for all existing ingredient items');
        const ingredientItems = document.querySelectorAll('.ingredient-item');
        ingredientItems.forEach(item => {
            initializeCronometerTextParser(item);
        });
    } else {
        console.warn('Cronometer text parser not available on page load');
    }

    // --- NEW: Weight Goal Elements ---
    const weightGoalForm = document.getElementById('weight-goal-form');
    const targetWeightInput = document.getElementById('targetWeight');
    const weeklyGainGoalInput = document.getElementById('weeklyGainGoal');
    const weightGoalStatus = document.getElementById('weight-goal-status');
    const weightGoalChartCanvas = document.getElementById('weight-goal-chart');
    const weightChartMessage = document.getElementById('weight-chart-message');
    const userSelector = document.getElementById('user-selector');
    const resetScaleButton = document.getElementById('reset-scale-button');
    const xAxisScaleSlider = document.getElementById('x-axis-scale');
    const yAxisScaleSlider = document.getElementById('y-axis-scale');
    const xScaleValue = document.getElementById('x-scale-value');
    const yScaleValue = document.getElementById('y-scale-value');
    let weightGoalChart = null; // To hold the Chart.js instance

    // Calorie Target Elements
    const calorieUserSelector = document.getElementById('calorie-user-selector');
    const calorieTargetInput = document.getElementById('calorie-target');
    const saveCalorieTargetBtn = document.getElementById('save-calorie-target');
    const currentCalorieTarget = document.getElementById('current-calorie-target');
    const calorieTargetStatus = document.getElementById('calorie-target-status');

    // Default scale values
    let xAxisScale = 1;
    let yAxisScale = 1;

    // Load saved user preference from localStorage or default to 1
    let currentUserId = localStorage.getItem('weightUserPreference') || 1;

    // Set the user selector to the saved preference
    if (userSelector && currentUserId) {
        userSelector.value = currentUserId;
    }
    // --- End Weight Goal Elements ---

    // Function to create HTML for a single ingredient row
    function createIngredientRowHtml() {
        return `
            <div class="ingredient-row">
                <!-- Ingredient Name, Amount, and Price stacked vertically -->
                <div class="ingredient-inputs-container">
                    <input type="text" placeholder="Ingredient Name" class="ingredient-name" required>
                    <input type="number" placeholder="Amount (g)" class="ingredient-amount" step="0.01" required>
                    <input type="number" placeholder="Package Amount (g)" class="ingredient-package-amount" step="0.01">
                    <input type="number" placeholder="Package Price" class="ingredient-price" step="0.01" required>
                    <!-- Hidden fields for form submission -->
                    <input type="hidden" class="ingredient-calories" required>
                    <input type="hidden" class="ingredient-protein" required>
                    <input type="hidden" class="ingredient-fat" required>
                    <input type="hidden" class="ingredient-carbs" required>
                </div>

                <!-- Cronometer Text Parser -->
                <div class="cronometer-text-paste-container">
                    <textarea class="cronometer-text-paste-area" placeholder="Paste Cronometer nutrition data here..." rows="5"></textarea>
                    <button type="button" class="cronometer-parse-button" onclick="if(window.processCronometerText){window.processCronometerText(this.parentNode.querySelector('.cronometer-text-paste-area').value.trim(), this.closest('.ingredient-item'), this.parentNode.querySelector('.cronometer-parse-status'))}">Parse Nutrition Data</button>
                    <div class="cronometer-parse-status"></div>
                </div>
            </div>

            <!-- Action buttons in one row -->
            <div class="buttons-row">
                <button type="button" class="toggle-detailed-nutrition">Show Detailed Nutrition</button>
                <button type="button" class="add-ingredient-btn-inline">Add Ingredient</button>
                <button type="button" class="remove-ingredient-btn">Remove</button>
            </div>

            <div class="detailed-nutrition-panel" style="display:none;">
                <!-- General Section -->
                <div class="nutrition-section">
                    <h4>General</h4>
                    <div class="nutrition-grid">
                        <div class="nutrition-item">
                            <label for="energy">Energy (kcal):</label>
                            <input type="number" class="nutrition-energy" step="0.1" required>
                        </div>
                        <div class="nutrition-item">
                            <label for="alcohol">Alcohol (g):</label>
                            <input type="number" class="nutrition-alcohol" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="caffeine">Caffeine (mg):</label>
                            <input type="number" class="nutrition-caffeine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="water">Water (g):</label>
                            <input type="number" class="nutrition-water" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- Carbohydrates Section -->
                <div class="nutrition-section">
                    <h4>Carbohydrates</h4>
                    <div class="nutrition-grid">
                        <div class="nutrition-item">
                            <label for="carbs-total">Carbs (g):</label>
                            <input type="number" class="nutrition-carbs-total" step="0.1" required>
                        </div>
                        <div class="nutrition-item">
                            <label for="fiber">Fiber (g):</label>
                            <input type="number" class="nutrition-fiber" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="starch">Starch (g):</label>
                            <input type="number" class="nutrition-starch" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="sugars">Sugars (g):</label>
                            <input type="number" class="nutrition-sugars" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="added-sugars">Added Sugars (g):</label>
                            <input type="number" class="nutrition-added-sugars" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="net-carbs">Net Carbs (g):</label>
                            <input type="number" class="nutrition-net-carbs" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- Lipids Section -->
                <div class="nutrition-section">
                    <h4>Lipids</h4>
                    <div class="nutrition-grid">
                        <div class="nutrition-item">
                            <label for="fat-total">Fat (g):</label>
                            <input type="number" class="nutrition-fat-total" step="0.1" required>
                        </div>
                        <div class="nutrition-item">
                            <label for="monounsaturated">Monounsaturated (g):</label>
                            <input type="number" class="nutrition-monounsaturated" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="polyunsaturated">Polyunsaturated (g):</label>
                            <input type="number" class="nutrition-polyunsaturated" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="omega3">Omega 3 (g):</label>
                            <input type="number" class="nutrition-omega3" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="omega6">Omega 6 (g):</label>
                            <input type="number" class="nutrition-omega6" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="saturated">Saturated (g):</label>
                            <input type="number" class="nutrition-saturated" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="trans-fat">Trans Fat (g):</label>
                            <input type="number" class="nutrition-trans-fat" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="cholesterol">Cholesterol (mg):</label>
                            <input type="number" class="nutrition-cholesterol" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- Protein Section -->
                <div class="nutrition-section">
                    <h4>Protein</h4>
                    <div class="nutrition-grid">
                        <div class="nutrition-item">
                            <label for="protein-total">Protein (g):</label>
                            <input type="number" class="nutrition-protein-total" step="0.1" required>
                        </div>
                        <div class="nutrition-item">
                            <label for="cystine">Cystine (g):</label>
                            <input type="number" class="nutrition-cystine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="histidine">Histidine (g):</label>
                            <input type="number" class="nutrition-histidine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="isoleucine">Isoleucine (g):</label>
                            <input type="number" class="nutrition-isoleucine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="leucine">Leucine (g):</label>
                            <input type="number" class="nutrition-leucine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="lysine">Lysine (g):</label>
                            <input type="number" class="nutrition-lysine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="methionine">Methionine (g):</label>
                            <input type="number" class="nutrition-methionine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="phenylalanine">Phenylalanine (g):</label>
                            <input type="number" class="nutrition-phenylalanine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="threonine">Threonine (g):</label>
                            <input type="number" class="nutrition-threonine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="tryptophan">Tryptophan (g):</label>
                            <input type="number" class="nutrition-tryptophan" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="tyrosine">Tyrosine (g):</label>
                            <input type="number" class="nutrition-tyrosine" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="valine">Valine (g):</label>
                            <input type="number" class="nutrition-valine" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- Vitamins Section -->
                <div class="nutrition-section">
                    <h4>Vitamins</h4>
                    <div class="nutrition-grid">
                        <div class="nutrition-item">
                            <label for="vitamin-b1">B1 (Thiamine) (mg):</label>
                            <input type="number" class="nutrition-vitamin-b1" step="0.01">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-b2">B2 (Riboflavin) (mg):</label>
                            <input type="number" class="nutrition-vitamin-b2" step="0.01">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-b3">B3 (Niacin) (mg):</label>
                            <input type="number" class="nutrition-vitamin-b3" step="0.01">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-b5">B5 (Pantothenic Acid) (mg):</label>
                            <input type="number" class="nutrition-vitamin-b5" step="0.01">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-b6">B6 (Pyridoxine) (mg):</label>
                            <input type="number" class="nutrition-vitamin-b6" step="0.01">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-b12">B12 (Cobalamin) (μg):</label>
                            <input type="number" class="nutrition-vitamin-b12" step="0.01">
                        </div>
                        <div class="nutrition-item">
                            <label for="folate">Folate (μg):</label>
                            <input type="number" class="nutrition-folate" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-a">Vitamin A (μg):</label>
                            <input type="number" class="nutrition-vitamin-a" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-c">Vitamin C (mg):</label>
                            <input type="number" class="nutrition-vitamin-c" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-d">Vitamin D (IU):</label>
                            <input type="number" class="nutrition-vitamin-d" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-e">Vitamin E (mg):</label>
                            <input type="number" class="nutrition-vitamin-e" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="vitamin-k">Vitamin K (μg):</label>
                            <input type="number" class="nutrition-vitamin-k" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- Minerals Section -->
                <div class="nutrition-section">
                    <h4>Minerals</h4>
                    <div class="nutrition-grid">
                        <div class="nutrition-item">
                            <label for="calcium">Calcium (mg):</label>
                            <input type="number" class="nutrition-calcium" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="copper">Copper (mg):</label>
                            <input type="number" class="nutrition-copper" step="0.01">
                        </div>
                        <div class="nutrition-item">
                            <label for="iron">Iron (mg):</label>
                            <input type="number" class="nutrition-iron" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="magnesium">Magnesium (mg):</label>
                            <input type="number" class="nutrition-magnesium" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="manganese">Manganese (mg):</label>
                            <input type="number" class="nutrition-manganese" step="0.01">
                        </div>
                        <div class="nutrition-item">
                            <label for="phosphorus">Phosphorus (mg):</label>
                            <input type="number" class="nutrition-phosphorus" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="potassium">Potassium (mg):</label>
                            <input type="number" class="nutrition-potassium" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="selenium">Selenium (μg):</label>
                            <input type="number" class="nutrition-selenium" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="sodium">Sodium (mg):</label>
                            <input type="number" class="nutrition-sodium" step="0.1">
                        </div>
                        <div class="nutrition-item">
                            <label for="zinc">Zinc (mg):</label>
                            <input type="number" class="nutrition-zinc" step="0.1">
                        </div>
                    </div>
                </div>
            </div>

            <div class="simplified-scan-status"></div>

            <!-- Raw OCR Text Container (initially hidden) -->
            <div class="raw-ocr-container" style="display: none;">
                <h4>Raw OCR Text</h4>
                <div class="raw-ocr-text"></div>
                <button class="raw-ocr-toggle">Hide Raw OCR Text</button>
            </div>
        `;
    }

    // Function to add a new ingredient row to the DOM
    function addIngredientRow() {
        const ingredientItem = document.createElement('div');
        ingredientItem.classList.add('ingredient-item');
        ingredientItem.innerHTML = createIngredientRowHtml();
        ingredientsList.appendChild(ingredientItem);

        // Wait for the DOM to update before initializing
        setTimeout(() => {
            // Initialize the Cronometer Text Parser in the new row
            if (typeof initializeCronometerTextParser === 'function') {
                initializeCronometerTextParser(ingredientItem);
                console.log('Cronometer Text Parser initialized in new ingredient row');
            } else {
                console.error('initializeCronometerTextParser function not found');
                // Try to load the cronometer-text-parser.js script if it's not loaded
                const scriptElement = document.createElement('script');
                scriptElement.src = '/js/food/cronometer-text-parser.js';
                scriptElement.onload = function() {
                    console.log('Cronometer Text Parser script loaded');
                    if (typeof initializeCronometerTextParser === 'function') {
                        initializeCronometerTextParser(ingredientItem);
                        console.log('Cronometer Text Parser initialized after script load');
                    }
                };
                document.head.appendChild(scriptElement);
            }

            // Manually add event listener to the parse button
            const parseButton = ingredientItem.querySelector('.cronometer-parse-button');
            const textPasteArea = ingredientItem.querySelector('.cronometer-text-paste-area');
            const statusElement = ingredientItem.querySelector('.cronometer-parse-status');

            if (parseButton && textPasteArea && statusElement) {
                parseButton.addEventListener('click', function() {
                    console.log('Parse button clicked');
                    const text = textPasteArea.value.trim();
                    if (text) {
                        if (typeof processCronometerText === 'function') {
                            console.log('Calling processCronometerText function');
                            processCronometerText(text, ingredientItem, statusElement);
                        } else {
                            console.error('processCronometerText function not found');
                            // Try to load the function from the global scope
                            if (window.processCronometerText) {
                                console.log('Found processCronometerText in window scope');
                                window.processCronometerText(text, ingredientItem, statusElement);
                            } else {
                                statusElement.textContent = 'Error: Nutrition parser not loaded';
                                statusElement.className = 'cronometer-parse-status error';
                            }
                        }
                    } else {
                        statusElement.textContent = 'Please paste Cronometer nutrition data first';
                        statusElement.className = 'cronometer-parse-status error';
                    }
                });
                console.log('Manual event listener added to parse button');
            }

            // Dispatch an event to notify that a new ingredient has been added
            // This allows other modules to initialize their functionality for the new ingredient
            const event = new CustomEvent('ingredientAdded', {
                detail: { ingredientItem: ingredientItem }
            });
            document.dispatchEvent(event);
            console.log('Dispatched ingredientAdded event');
        }, 100); // Slightly longer timeout to ensure DOM is updated

        // Note: Remove button listener is handled by delegation
    }

    // Event listener for removing ingredients and toggling detailed nutrition (delegated to the list container)
    ingredientsList.addEventListener('click', (event) => {
        // Handle remove ingredient button
        if (event.target.classList.contains('remove-ingredient-btn')) {
            // Prevent removing the last ingredient row
            if (ingredientsList.children.length > 1) {
                event.target.closest('.ingredient-item').remove();
            } else {
                alert("A recipe must have at least one ingredient.");
            }
        }

        // Handle detailed nutrition toggle button
        if (event.target.classList.contains('toggle-detailed-nutrition')) {
            const button = event.target;
            const panel = button.closest('.ingredient-item').querySelector('.detailed-nutrition-panel');

            if (panel) {
                // Toggle visibility
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';

                // Update button text and class
                if (isVisible) {
                    button.textContent = 'Show Detailed Nutrition';
                    button.classList.remove('active');
                } else {
                    button.textContent = 'Hide Detailed Nutrition';
                    button.classList.add('active');
                }
            }
        }

        // Handle inline add ingredient button
        if (event.target.classList.contains('add-ingredient-btn-inline')) {
            addIngredientRow();
        }
    });

    // Event listener for form submission
    createRecipeForm.addEventListener('submit', async (event) => {
        event.preventDefault(); // Prevent default form submission
        console.log('Recipe form submitted');
        showStatus(createRecipeStatus, 'Saving recipe...', 'info'); // Indicate processing

        const recipeName = recipeNameInput.value.trim();
        console.log('Recipe name:', recipeName);

        const ingredientItems = ingredientsList.querySelectorAll('.ingredient-item');
        console.log(`Found ${ingredientItems.length} ingredient items`);

        const ingredientsData = [];
        let formIsValid = true;

        if (!recipeName) {
            showStatus(createRecipeStatus, 'Recipe name is required.', 'error');
            return;
        }

        if (ingredientItems.length === 0) {
            // This case should ideally not happen due to the remove button logic, but check anyway
            showStatus(createRecipeStatus, 'Recipe must have at least one ingredient.', 'error');
            return;
        }

        // Collect and validate ingredient data
        ingredientItems.forEach(item => {
            const name = item.querySelector('.ingredient-name').value.trim();
            // Get values from detailed nutrition fields first, then fall back to hidden fields
            const energyInput = item.querySelector('.nutrition-energy');
            const proteinTotalInput = item.querySelector('.nutrition-protein-total');
            const fatTotalInput = item.querySelector('.nutrition-fat-total');
            const carbsTotalInput = item.querySelector('.nutrition-carbs-total');

            // Get values from detailed fields if available, otherwise use hidden fields
            const calories = parseFloat(energyInput ? energyInput.value : item.querySelector('.ingredient-calories').value);
            const amount = parseFloat(item.querySelector('.ingredient-amount').value);
            const packageAmount = parseFloat(item.querySelector('.ingredient-package-amount').value || 0); // Default to 0 if empty
            const protein = parseFloat(proteinTotalInput ? proteinTotalInput.value : item.querySelector('.ingredient-protein').value);
            const fat = parseFloat(fatTotalInput ? fatTotalInput.value : item.querySelector('.ingredient-fat').value);
            const carbs = parseFloat(carbsTotalInput ? carbsTotalInput.value : item.querySelector('.ingredient-carbs').value);
            const price = parseFloat(item.querySelector('.ingredient-price').value);

            // Update hidden fields with the latest values from detailed fields
            if (energyInput && energyInput.value) item.querySelector('.ingredient-calories').value = energyInput.value;
            if (proteinTotalInput && proteinTotalInput.value) item.querySelector('.ingredient-protein').value = proteinTotalInput.value;
            if (fatTotalInput && fatTotalInput.value) item.querySelector('.ingredient-fat').value = fatTotalInput.value;
            if (carbsTotalInput && carbsTotalInput.value) item.querySelector('.ingredient-carbs').value = carbsTotalInput.value;

            // Leave empty fields as empty (no default values)

            // Convert empty strings to null for validation
            const caloriesVal = calories === '' ? null : calories;
            const proteinVal = protein === '' ? null : protein;
            const fatVal = fat === '' ? null : fat;
            const carbsVal = carbs === '' ? null : carbs;
            const priceVal = price === '' ? null : price;

            if (!name || isNaN(caloriesVal) || isNaN(amount) || isNaN(proteinVal) || isNaN(fatVal) || isNaN(carbsVal) || isNaN(priceVal) || amount <= 0 ||
                (caloriesVal !== null && caloriesVal < 0) ||
                (proteinVal !== null && proteinVal < 0) ||
                (fatVal !== null && fatVal < 0) ||
                (carbsVal !== null && carbsVal < 0) ||
                (priceVal !== null && priceVal < 0)) {
                formIsValid = false;
                item.style.border = '1px solid red'; // Highlight invalid rows
            } else {
                item.style.border = ''; // Clear highlight on valid rows

                // Create the basic ingredient data
                const ingredientData = {
                    name,
                    calories: caloriesVal,
                    amount,
                    package_amount: packageAmount || null, // Include package amount, null if 0
                    protein: proteinVal,
                    fats: fatVal,
                    carbohydrates: carbsVal,
                    price: priceVal
                };

                // Add all hidden fields to the ingredient data
                const hiddenFields = item.querySelectorAll('input[type="hidden"]');
                hiddenFields.forEach(field => {
                    // Skip the basic fields we've already added
                    if (field.className === 'ingredient-calories' ||
                        field.className === 'ingredient-protein' ||
                        field.className === 'ingredient-fat' ||
                        field.className === 'ingredient-carbs') {
                        return;
                    }

                    // Extract the field name from the class name
                    const fieldName = field.className.replace('ingredient-', '');

                    // Skip empty fields
                    if (!field.value) return;

                    // Convert to number if possible
                    const value = parseFloat(field.value);
                    if (!isNaN(value)) {
                        ingredientData[fieldName] = value;
                        console.log(`Added micronutrient data from hidden field: ${fieldName} = ${value}`);
                    }
                });

                // Double-check if we have any micronutrient data
                let hasMicronutrients = false;
                for (const [key, value] of Object.entries(ingredientData)) {
                    if (!['name', 'calories', 'amount', 'protein', 'fats', 'carbohydrates', 'price', 'package_amount'].includes(key)) {
                        hasMicronutrients = true;
                        console.log(`Found micronutrient data: ${key} = ${value}`);
                    }
                }

                if (!hasMicronutrients) {
                    console.warn(`No micronutrient data found in hidden fields for ingredient ${ingredientData.name}`);
                }

                // Check if we have complete nutrition data from Cronometer parser
                if (item.dataset.completeNutritionData) {
                    try {
                        // Parse the complete nutrition data
                        const completeData = JSON.parse(item.dataset.completeNutritionData);
                        console.log('Found complete nutrition data:', completeData);

                        // Get the database format data
                        if (window.NutritionFieldMapper) {
                            const dbFormatData = window.NutritionFieldMapper.toDbFormat(completeData);

                            // Log the database format data for debugging
                            console.log('Database format data from Cronometer parser:', dbFormatData);

                            // Merge the database format data with the ingredient data
                            for (const [key, value] of Object.entries(dbFormatData)) {
                                // Skip null or undefined values
                                if (value === null || value === undefined) continue;

                                // Skip basic fields that are already handled
                                if (['name', 'calories', 'amount', 'protein', 'fats', 'carbohydrates', 'price', 'package_amount'].includes(key)) {
                                    continue;
                                }

                                // Add the field to the ingredient data
                                ingredientData[key] = value;
                                console.log(`Added micronutrient data: ${key} = ${value}`);
                            }
                        } else {
                            // If NutritionFieldMapper is not available, use the complete data directly
                            Object.assign(ingredientData, completeData);
                        }

                        // Make sure the basic fields are not overwritten
                        ingredientData.name = name;
                        ingredientData.calories = caloriesVal;
                        ingredientData.amount = amount;
                        ingredientData.package_amount = packageAmount || null;
                        ingredientData.protein = proteinVal;
                        ingredientData.fats = fatVal;
                        ingredientData.carbohydrates = carbsVal;
                        ingredientData.price = priceVal;

                        console.log('Final ingredient data with micronutrients:', ingredientData);
                    } catch (error) {
                        console.error('Error parsing complete nutrition data:', error);
                    }
                }

                // Add the ingredient data to the array
                // Log the ingredient data before adding it to the array
                console.log(`Adding ingredient ${ingredientData.name} to ingredientsData:`, ingredientData);

                // Check if we have any micronutrient data
                let hasAnyMicronutrients = false;
                for (const [key, value] of Object.entries(ingredientData)) {
                    if (!['name', 'calories', 'amount', 'protein', 'fats', 'carbohydrates', 'price', 'package_amount'].includes(key)) {
                        hasAnyMicronutrients = true;
                        break;
                    }
                }

                if (!hasAnyMicronutrients) {
                    console.warn(`No micronutrient data found for ingredient ${ingredientData.name}`);

                    // Check if we have complete nutrition data
                    if (item.dataset.completeNutritionData) {
                        console.log('Found complete nutrition data, trying to add micronutrients again');

                        try {
                            // Parse the complete nutrition data
                            const nutritionData = JSON.parse(item.dataset.completeNutritionData);

                            // Get the database format data
                            if (window.NutritionFieldMapper) {
                                const dbFormatData = window.NutritionFieldMapper.toDbFormat(nutritionData);

                                // Add all micronutrient data to the ingredient data
                                for (const [key, value] of Object.entries(dbFormatData)) {
                                    // Skip null or undefined values
                                    if (value === null || value === undefined) continue;

                                    // Skip basic fields that are already handled
                                    if (['name', 'calories', 'amount', 'protein', 'fats', 'carbohydrates', 'price', 'package_amount'].includes(key)) {
                                        continue;
                                    }

                                    // Add the field to the ingredient data
                                    ingredientData[key] = value;
                                    console.log(`Added micronutrient data: ${key} = ${value}`);
                                }
                            }
                        } catch (error) {
                            console.error('Error adding micronutrient data:', error);
                        }
                    }
                }

                ingredientsData.push(ingredientData);
            }
        });

        if (!formIsValid) {
            showStatus(createRecipeStatus, 'Please fill all ingredient fields correctly (all values >= 0, amount > 0).', 'error');
            return;
        }

        // --- Send data to backend --- //
        try {
            // Log the data being sent to the backend
            console.log('Sending data to backend:', { name: recipeName, ingredients: ingredientsData });
            console.log('JSON data:', JSON.stringify({ name: recipeName, ingredients: ingredientsData }, null, 2));

            // Log each ingredient's micronutrient data
            ingredientsData.forEach((ingredient, index) => {
                console.log(`Ingredient ${index + 1} (${ingredient.name}) micronutrient data:`);

                // Count micronutrient fields
                let micronutrientCount = 0;

                for (const [key, value] of Object.entries(ingredient)) {
                    // Skip basic fields
                    if (['name', 'calories', 'amount', 'protein', 'fats', 'carbohydrates', 'price', 'package_amount'].includes(key)) {
                        console.log(`  Basic field: ${key}: ${value}`);
                        continue;
                    }
                    console.log(`  Micronutrient: ${key}: ${value}`);
                    micronutrientCount++;
                }

                console.log(`Ingredient ${index + 1} (${ingredient.name}) has ${micronutrientCount} micronutrient fields`);

                // Add a special flag to indicate that this ingredient has micronutrient data
                if (micronutrientCount > 0) {
                    ingredient.has_micronutrients = true;
                    console.log(`  Added has_micronutrients flag to ${ingredient.name}`);
                }
            });

            console.log('Sending POST request to /api/recipes...');
            const response = await fetch('/api/recipes', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache'
                },
                body: JSON.stringify({ name: recipeName, ingredients: ingredientsData })
            });

            console.log('Response status:', response.status);
            console.log('Response headers:', Object.fromEntries([...response.headers.entries()]));

            if (!response.ok) {
                const errorText = await response.text();
                console.error('Error response:', errorText);

                try {
                    const errorData = JSON.parse(errorText);
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                } catch (jsonError) {
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }
            }

            console.log('Parsing response JSON...');
            const newRecipe = await response.json();
            console.log('Recipe saved successfully:', newRecipe);

            // Show a more visible confirmation message
            showStatus(createRecipeStatus, `Recipe '${newRecipe.name}' saved successfully!`, 'success');

            // Create a popup notification
            const notification = document.createElement('div');
            notification.className = 'save-notification';
            notification.innerHTML = `
                <div class="save-notification-content">
                    <span class="save-notification-icon">✓</span>
                    <span class="save-notification-text">Recipe '${newRecipe.name}' saved successfully!</span>
                </div>
            `;
            document.body.appendChild(notification);

            // Add styles for the notification
            const style = document.createElement('style');
            style.textContent = `
                .save-notification {
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background-color: #000;
                    color: white;
                    padding: 25px 30px;
                    border-radius: 5px;
                    z-index: 9999;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
                    border: 2px solid #00ff00;
                    animation: pulseAndFade 5s forwards;
                    min-width: 300px;
                    text-align: center;
                }
                .save-notification-content {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                .save-notification-icon {
                    color: #00ff00;
                    font-size: 30px;
                    margin-right: 15px;
                    animation: pulse 1s infinite;
                }
                .save-notification-text {
                    font-size: 20px;
                    font-weight: bold;
                }
                @keyframes pulseAndFade {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    10% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    20% { transform: translate(-50%, -50%) scale(1); }
                    80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                }
                @keyframes pulse {
                    0% { transform: scale(1); }
                    50% { transform: scale(1.2); }
                    100% { transform: scale(1); }
                }
            `;
            document.head.appendChild(style);

            // Remove the notification after 5 seconds (matching the animation duration)
            setTimeout(() => {
                notification.remove();
                style.remove();
            }, 5000);

            createRecipeForm.reset(); // Clear form fields

            // Reset ingredients list to one empty row
            console.log('Clearing ingredient list and adding empty row...');
            ingredientsList.innerHTML = '';
            addIngredientRow(); // This will also initialize the paste area

            console.log('Refreshing recipe list...');
            // Add a small delay before refreshing to ensure the database transaction is complete
            setTimeout(() => {
                loadRecipes(0, 3); // Refresh the recipe list with retry mechanism
            }, 500);

        } catch (error) {
            console.error('Error saving recipe:', error);
            showStatus(createRecipeStatus, `Error saving recipe: ${error.message}`, 'error');
        }
    });

    // --- NEW: Weight Goal Functions --- //

    async function loadWeightGoal() {
        showStatus(weightGoalStatus, 'Loading weight goal...', 'info');
        try {
            const response = await fetch(`/api/weight/goal?user_id=${currentUserId}`);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to fetch goal');
            }
            const goalData = await response.json();

            // goalData might be { target_weight: null, weekly_gain_goal: null } if not set
            targetWeightInput.value = goalData.target_weight || '';
            weeklyGainGoalInput.value = goalData.weekly_gain_goal || '';
            showStatus(weightGoalStatus, '', ''); // Clear loading status

        } catch (error) {
            console.error('Error loading weight goal:', error);
            showStatus(weightGoalStatus, `Error loading goal: ${error.message}`, 'error');
        }
    }

    async function saveWeightGoal(event) {
        event.preventDefault();
        const targetWeight = parseFloat(targetWeightInput.value);
        const weeklyGain = parseFloat(weeklyGainGoalInput.value);

        if (isNaN(targetWeight) || targetWeight <= 0 || isNaN(weeklyGain) || weeklyGain === 0) {
            showStatus(weightGoalStatus, 'Please enter a valid positive number for target weight and a non-zero value for weekly goal.', 'error');
            return;
        }

        showStatus(weightGoalStatus, 'Saving goal...', 'info');
        try {
            // Get the most recent weight log to use as the starting point
            const logsResponse = await fetch(`/api/weight/logs?user_id=${currentUserId}`);
            if (!logsResponse.ok) {
                throw new Error('Failed to fetch weight logs');
            }

            const logs = await logsResponse.json();
            let startWeight = null;
            let startDate = null;

            if (logs && logs.length > 0) {
                // Sort logs by date (newest first)
                logs.sort((a, b) => new Date(b.log_date || b.date) - new Date(a.log_date || a.date));
                startWeight = logs[0].weight;
                startDate = logs[0].log_date || logs[0].date;
                console.log(`Using most recent weight log: ${startWeight} lbs on ${startDate}`);
            } else {
                // If no logs exist, use the current weight goal as the starting point
                startWeight = targetWeight;
                // Use today's date
                const today = new Date();
                startDate = today.toISOString().split('T')[0];
                console.log(`No weight logs found, using target weight (${startWeight} lbs) and today's date (${startDate})`);
            }

            const response = await fetch('/api/weight/goal', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    targetWeight: targetWeight,
                    weeklyGain: weeklyGain,
                    startWeight: startWeight,
                    startDate: startDate,
                    user_id: currentUserId
                })
            });

            if (!response.ok) {
                 const errorData = await response.json();
                 throw new Error(errorData.error || 'Failed to save goal');
            }

            const result = await response.json();
            console.log("Goal saved:", result);

            // Update inputs to reflect saved values (in case of rounding/validation on backend)
            targetWeightInput.value = result.target_weight || '';
            weeklyGainGoalInput.value = result.weekly_gain_goal || '';

            showStatus(weightGoalStatus, 'Weight goal saved successfully!', 'success');
            // Trigger graph update as the goal line might change
            loadAndRenderWeightChart();

        } catch (error) {
            console.error('Error saving weight goal:', error);
            showStatus(weightGoalStatus, `Error saving goal: ${error.message}`, 'error');
        }
    }

    // --- NEW: Weight Chart Functions --- //

    // Loads actual weight data and goal line, then renders the chart
    async function loadAndRenderWeightChart() {
        // IMPORTANT: Make sure Chart.js library is included in food.html
        // <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        if (!weightGoalChartCanvas) return;

        weightChartMessage.textContent = 'Loading chart data...';
        weightChartMessage.style.display = 'block';
        weightGoalChartCanvas.style.display = 'none'; // Hide canvas while loading
        if (weightGoalChart) weightGoalChart.destroy(); // Clear previous chart immediately

        try {
            // Fetch both logs and goal data concurrently
            const [logsResponse, goalResponse] = await Promise.all([
                fetch(`/api/weight/logs?user_id=${currentUserId}`),
                fetch(`/api/weight/goal?user_id=${currentUserId}`)
            ]);

            if (!logsResponse.ok) {
                const errorData = await logsResponse.json();
                throw new Error(errorData.error || 'Failed to fetch weight logs');
            }
            if (!goalResponse.ok) {
                const errorData = await goalResponse.json();
                throw new Error(errorData.error || 'Failed to fetch weight goal');
            }

            const weightLogs = await logsResponse.json(); // Expecting [{ log_id, log_date (YYYY-MM-DD), weight }, ...]
            const goalData = await goalResponse.json(); // Expecting { target_weight, weekly_gain_goal }

            if (!Array.isArray(weightLogs)) {
                 throw new Error('Invalid format received for weight logs.');
            }

            if (weightLogs.length === 0) {
                weightChartMessage.textContent = 'Log your weight to see the chart.';
                weightChartMessage.style.display = 'block';
                weightGoalChartCanvas.style.display = 'none';
                // No need to destroy chart again, done above
                return;
            }

            // --- Prepare data for Chart.js ---
            // Ensure logs are sorted by date (API should do this, but double-check)
            weightLogs.sort((a, b) => new Date(a.log_date) - new Date(b.log_date));

            // Get today's date for the current day indicator
            const today = new Date();
            const todayFormatted = today.toISOString().split('T')[0]; // YYYY-MM-DD format

            // Check if today's date is already in the logs
            const todayInLogs = weightLogs.some(log => log.log_date === todayFormatted);

            // If today's date is not in the logs, add it to the logs array
            if (!todayInLogs) {
                // Find where to insert today's date (in chronological order)
                let insertIndex = weightLogs.length; // Default to end of array
                for (let i = 0; i < weightLogs.length; i++) {
                    if (new Date(weightLogs[i].log_date) > today) {
                        insertIndex = i;
                        break;
                    }
                }

                // Insert today's date at the appropriate position
                weightLogs.splice(insertIndex, 0, {
                    log_id: null,
                    log_date: todayFormatted,
                    weight: null // No weight data for today yet
                });

                console.log(`Added today's date (${todayFormatted}) to the chart at position ${insertIndex}`);
            }

            const histLabels = weightLogs.map(log => new Date(log.log_date + 'T00:00:00Z').toLocaleDateString()); // Use UTC date for consistency
            const actualWeightData = weightLogs.map(log => log.weight);

            // --- Generate Future Dates and Labels ---
            const futureLabels = [];
            const WEEKS_TO_PROJECT = 12; // Project ~12 weeks into the future for longer-term goals

            // Find the most recent actual weight (for comparison with goal weights)
            let mostRecentWeight = null;
            let mostRecentDate = null;

            // Loop through weight logs in reverse to find the most recent non-null weight
            for (let i = weightLogs.length - 1; i >= 0; i--) {
                if (weightLogs[i].weight !== null) {
                    mostRecentWeight = weightLogs[i].weight;
                    mostRecentDate = weightLogs[i].log_date;
                    break;
                }
            }

            // Store the most recent weight for tooltip reference
            window.mostRecentWeight = {
                weight: mostRecentWeight,
                date: mostRecentDate
            };

            console.log(`Most recent weight: ${mostRecentWeight} lbs on ${mostRecentDate}`);

            // Get the goal data to determine the start date for future projections
            let goalStartDate;

            if (goalData.start_date) {
                // Use the saved start date from when the goal was set
                goalStartDate = new Date(goalData.start_date);
                console.log("Using goal start date for projections:", goalStartDate.toLocaleDateString());
            } else {
                // Fallback to today's date if no start date is available
                goalStartDate = new Date();
                console.log("No goal start date available, using today:", goalStartDate.toLocaleDateString());
            }

            goalStartDate.setHours(0, 0, 0, 0);

            // Store weekly increment dates and goal weights for tooltip reference and custom weight editing
            window.weeklyIncrementDates = [];
            window.weeklyGoalWeights = [];

            // Generate future dates exactly 7 days apart (weekly) starting from the goal start date
            for (let i = 0; i <= WEEKS_TO_PROJECT; i++) { // Start from 0 to include the start date
                // Create a new date for each iteration to avoid modifying the original
                const futureDate = new Date(goalStartDate);

                // Add days for weeks after the first one (i > 0)
                if (i > 0) {
                    futureDate.setDate(futureDate.getDate() + (i * 7)); // Add exactly 7 days each time
                }

                // Debug log to see the exact date format
                if (i === 0) {
                    console.log("First future date:", futureDate);
                    console.log("First future date formatted:", futureDate.toLocaleDateString());
                    console.log("First future date ISO:", futureDate.toISOString());
                }

                // Include all dates from the fixed start date
                futureLabels.push(futureDate.toLocaleDateString());

                // Store this date as a weekly increment point
                window.weeklyIncrementDates.push({
                    date: futureDate.toLocaleDateString(),
                    index: histLabels.length + futureLabels.length - 1, // Index in the combined labels array
                    week: i
                });

                console.log(`Added future date: ${futureDate.toLocaleDateString()} (week ${i})`);
            }

            // --- Combine Labels and Pad Actual Data ---
            const labels = [...histLabels, ...futureLabels];
            // Pad actual weight data with nulls for the future dates
            const paddedActualWeightData = [...actualWeightData, ...Array(futureLabels.length).fill(null)];

            // --- Calculate Full Target Weight Line (Historical + Future) ---
            const targetWeightLine = [];

            // Use the start weight and date from the goal data
            // This ensures we use the date when the goal was set as the starting point
            let startDate;
            let startWeight;

            if (goalData.start_date && goalData.start_weight) {
                // Use the saved start date and weight from when the goal was set
                startDate = new Date(goalData.start_date);
                startWeight = goalData.start_weight;
                console.log(`Using goal start date: ${goalData.start_date} and start weight: ${startWeight} lbs`);
            } else {
                // Fallback to most recent weight log if start date/weight not available
                // Find the most recent weight log
                let mostRecentLog = null;
                for (let i = weightLogs.length - 1; i >= 0; i--) {
                    if (weightLogs[i].weight !== null) {
                        mostRecentLog = weightLogs[i];
                        break;
                    }
                }

                if (mostRecentLog) {
                    startDate = new Date(mostRecentLog.log_date);
                    startWeight = mostRecentLog.weight;
                    console.log(`Using most recent weight log as start: ${startWeight} lbs on ${mostRecentLog.log_date}`);
                } else {
                    // Last resort fallback to today and target weight
                    startDate = new Date();
                    startWeight = goalData.target_weight;
                    console.log(`No start data available, using today and target weight: ${startWeight} lbs`);
                }
            }

            const targetWeight = goalData.target_weight;
            const weeklyGain = goalData.weekly_gain_goal;

            // --- Add Logging ---
            console.log("Chart: Received goalData:", goalData);
            console.log("Chart: Values for target line calculation:",
                { targetWeight, weeklyGain, startDate, startWeight });
            // --- End Logging ---

            // Create an array to store weekly goal weights
            window.weeklyGoalWeights = [];

            // Debug log to see what weekly increment dates we have
            console.log("Weekly increment dates:", window.weeklyIncrementDates);

            if (targetWeight !== null && weeklyGain !== null && weeklyGain !== 0 && !isNaN(targetWeight) && !isNaN(weeklyGain)) {
                console.log("Chart: Condition to draw target line met."); // Log condition met

                // Use the goal start date as the reference date for filtering
                const filterDate = new Date(startDate);
                filterDate.setHours(0, 0, 0, 0);

                // Iterate through the COMBINED labels array to calculate target for each date point
                labels.forEach((labelStr, index) => {
                    // Convert label string back to Date object for calculation
                    // We need to handle different date formats
                    let currentDate;

                    // Try parsing MM/DD/YYYY format first
                    if (labelStr.includes('/')) {
                        const parts = labelStr.split('/');
                        if (parts.length === 3) {
                            // MM/DD/YYYY format
                            currentDate = new Date(parts[2], parts[0] - 1, parts[1]);
                        }
                    }

                    // If that didn't work, try direct parsing
                    if (!currentDate || isNaN(currentDate.getTime())) {
                        currentDate = new Date(labelStr);
                    }

                    // If still invalid, log and skip
                    if (isNaN(currentDate.getTime())) {
                        console.warn(`Could not parse date label for target line calculation: ${labelStr}`);
                        targetWeightLine.push(null); // Push null if date is invalid
                        return; // Skip to next iteration
                    }

                    // Ensure both dates use the same time basis
                    currentDate.setUTCHours(0, 0, 0, 0);

                    // Check if this date is on or after our fixed start date (May 6, 2024)
                    const isOnOrAfterStartDate = currentDate >= filterDate;

                    // For dates before our fixed start date, push null to hide the goal line
                    if (!isOnOrAfterStartDate) {
                        targetWeightLine.push(null);
                        return; // Skip to next iteration
                    }

                    // Calculate exact number of weeks between dates
                    // Use milliseconds for precise calculation
                    const msDiff = currentDate.getTime() - startDate.getTime();
                    const daysDiff = msDiff / (1000 * 60 * 60 * 24);
                    const weeksDiff = daysDiff / 7;

                    // Only calculate projection if weeksDiff is non-negative (i.e., date is on or after start date)
                    if (weeksDiff >= 0) {
                        // Calculate projected weight based on start weight and weekly gain
                        const projectedWeight = startWeight + (weeksDiff * weeklyGain);
                        console.log(`Date: ${labelStr}, Weeks from start: ${weeksDiff.toFixed(2)}, Projected: ${projectedWeight.toFixed(2)} lbs`);
                        let goalWeight;

                        // Handle weight gain vs weight loss differently
                        if (weeklyGain > 0) {
                            // For weight gain, cap at target weight (which is higher than start weight)
                            goalWeight = Math.min(projectedWeight, targetWeight);
                            targetWeightLine.push(goalWeight);
                        } else {
                            // For weight loss, cap at target weight (which is lower than start weight)
                            goalWeight = Math.max(projectedWeight, targetWeight);
                            targetWeightLine.push(goalWeight);
                        }

                        // Store the goal weight for this date
                        // Check if this is a weekly increment point
                        const weeklyPoint = window.weeklyIncrementDates.find(w => w.index === index);
                        if (weeklyPoint) {
                            const weeklyGoalWeight = {
                                index: index,
                                date: labelStr,
                                weight: goalWeight,
                                week: weeklyPoint.week
                            };
                            window.weeklyGoalWeights.push(weeklyGoalWeight);
                            console.log(`Added weekly goal weight: ${labelStr}, ${goalWeight.toFixed(2)} lbs (week ${weeklyPoint.week})`);

                            // Store the date for this week number for custom goal weights feature
                            window.weeklyIncrementDates[weeklyPoint.week] = labelStr;
                        }
                    } else {
                        // If somehow a date before start date is processed, push null
                        targetWeightLine.push(null);
                    }
                });
            } else {
                console.log("Goal not set or invalid, not drawing target line.");
                // Ensure targetWeightLine has the same length as labels, filled with nulls
                for (let i = 0; i < labels.length; i++) { targetWeightLine.push(null); }
            }
            // --- End Target Line Calculation ---

            // Pass the target weight value to the renderWeightChart function
            renderWeightChart(labels, paddedActualWeightData, targetWeightLine, parseFloat(goalData.target_weight));
            weightChartMessage.style.display = 'none'; // Hide message
            weightGoalChartCanvas.style.display = 'block'; // Show canvas

            // Initialize custom goal weights functionality
            if (window.customGoalWeights && typeof window.customGoalWeights.init === 'function') {
                window.customGoalWeights.init();
            }

            // Load custom goal weights
            if (window.customGoalWeights && typeof window.customGoalWeights.load === 'function') {
                window.customGoalWeights.load();
            }

        } catch (error) {
            console.error("Error loading data for weight chart:", error);
            weightChartMessage.textContent = `Error loading chart data: ${error.message}`;
            weightChartMessage.style.color = 'red';
            weightChartMessage.style.display = 'block';
            weightGoalChartCanvas.style.display = 'none';
            // No need to destroy chart again, done above
        }
    }

    function renderWeightChart(labels, actualData, targetData, targetWeight) {
        if (!weightGoalChartCanvas) return;
        const ctx = weightGoalChartCanvas.getContext('2d');

        if (weightGoalChart) {
            weightGoalChart.destroy(); // Destroy previous instance
        }

        // Convert data to proper format for Chart.js
        const formattedActualData = [];
        const formattedTargetData = [];

        // Track the most recent weight for comparison with goal weights
        window.mostRecentWeight = { weight: null, date: null };

        // Format actual weight data - use actual array indices for x values
        for (let i = 0; i < labels.length; i++) {
            formattedActualData.push({
                x: i,
                y: actualData[i] // Keep null values to maintain line continuity
            });

            // Update most recent weight if this entry has a weight value
            if (actualData[i] !== null && actualData[i] !== undefined) {
                if (window.mostRecentWeight.weight === null || i > window.mostRecentWeight.index) {
                    window.mostRecentWeight = {
                        weight: actualData[i],
                        date: labels[i],
                        index: i
                    };
                }
            }
        }

        console.log('Most recent weight:', window.mostRecentWeight);

        // Format target weight data - use actual array indices for x values
        for (let i = 0; i < labels.length; i++) {
            formattedTargetData.push({
                x: i,
                y: targetData[i] // Keep null values to maintain line continuity
            });
        }

        const datasets = [
            {
                label: 'Actual Weight (lbs)',
                data: formattedActualData,
                borderColor: '#3498db', // Blue
                backgroundColor: 'rgba(52, 152, 219, 0.2)',
                borderWidth: 3,
                tension: 0, // Set to 0 for straight lines
                fill: true,
                pointBackgroundColor: '#3498db',
                pointBorderColor: '#fff',
                pointBorderWidth: 2,
                pointRadius: 5,
                pointHoverRadius: 10, // Even larger hover radius for better visibility
                pointHoverBackgroundColor: '#2980b9', // Darker blue on hover
                pointHoverBorderColor: '#fff',
                pointHoverBorderWidth: 3, // Thicker border on hover
                // Add shadow effect on hover
                pointHoverShadowColor: 'rgba(0, 0, 0, 0.5)',
                pointHoverShadowBlur: 10,
                pointHoverShadowOffsetX: 0,
                pointHoverShadowOffsetY: 4,
                // Ensure tooltips work properly
                hitRadius: 15, // Increase hit detection radius for easier interaction
                spanGaps: true, // Connect points across gaps (null values)
                // Ensure points are always drawn regardless of zoom level
                pointRadius: 5, // Fixed point size
                // Make sure points are always visible
                z: 10, // Higher z-index to keep points on top
                // Don't clip points at the edges
                clip: false,
                // Keep points in view when zooming
                borderJoinStyle: 'round',
                // Improve tooltip interaction
                interaction: {
                    mode: 'nearest',
                    axis: 'xy',
                    intersect: false
                },
                segment: {
                    borderColor: ctx => {
                        // Only draw line segments where we have actual data
                        const p0 = ctx.p0.parsed;
                        const p1 = ctx.p1.parsed;
                        return (p0.y === null || p1.y === null) ? 'transparent' : '#3498db';
                    }
                }
            }
        ];

        // Add target weight line dataset if data exists
        if (formattedTargetData.length > 0) {
             console.log("Adding goal weight path dataset with weekly goal weights:", window.weeklyGoalWeights);
             datasets.push({
                 label: 'Goal Weight Path (lbs)',
                 data: formattedTargetData,
                 borderColor: '#e74c3c', // Red
                 borderDash: [5, 5], // Dashed line
                 borderWidth: 2,
                 tension: 0, // Set to 0 for straight lines
                 fill: false,
                 // Show points only at weekly increments
                 pointRadius: function(context) {
                     // Check if this is a weekly increment point
                     if (window.weeklyGoalWeights && window.weeklyGoalWeights.length > 0) {
                         const isWeeklyPoint = window.weeklyGoalWeights.some(w => w.index === context.dataIndex);
                         return isWeeklyPoint ? 3 : 0; // 3px radius for weekly points, 0 for others
                     }
                     return 0;
                 },
                 // Add very subtle shadow to weekly points
                 pointShadowBlur: 2,
                 pointShadowColor: 'rgba(0, 0, 0, 0.2)',
                 pointBackgroundColor: function(context) {
                     // Check if this is a weekly increment point
                     if (window.weeklyGoalWeights && window.weeklyGoalWeights.length > 0) {
                         const isWeeklyPoint = window.weeklyGoalWeights.some(w => w.index === context.dataIndex);
                         return isWeeklyPoint ? '#e74c3c' : 'transparent'; // Red for weekly points
                     }
                     return 'transparent';
                 },
                 pointBorderColor: function(context) {
                     // Check if this is a weekly increment point
                     if (window.weeklyGoalWeights && window.weeklyGoalWeights.length > 0) {
                         const isWeeklyPoint = window.weeklyGoalWeights.some(w => w.index === context.dataIndex);
                         return isWeeklyPoint ? '#fff' : 'transparent'; // White border for weekly points
                     }
                     return 'transparent';
                 },
                 pointBorderWidth: 1,
                 pointHoverRadius: 5, // Moderate hover radius for better UX
                 pointHoverBackgroundColor: '#c0392b', // Darker red on hover
                 pointHoverBorderColor: '#fff',
                 pointHoverBorderWidth: 2,
                 spanGaps: true, // Connect points across gaps (null values)
                 segment: {
                     borderColor: ctx => {
                         // Only draw line segments where we have actual data
                         const p0 = ctx.p0.parsed;
                         const p1 = ctx.p1.parsed;
                         return (p0.y === null || p1.y === null) ? 'transparent' : '#e74c3c';
                     }
                 }
             });
        }

        // Find today's date in the labels array
        const today = new Date();
        const todayFormatted = today.toLocaleDateString();

        console.log('Today formatted:', todayFormatted);
        console.log('Available labels:', labels);

        // Try different date formats to find today in the labels
        let todayIndex = -1;

        // Method 1: Direct match
        todayIndex = labels.findIndex(label => label === todayFormatted);

        // Method 2: Try MM/DD/YYYY format
        if (todayIndex === -1) {
            const month = (today.getMonth() + 1).toString().padStart(2, '0');
            const day = today.getDate().toString().padStart(2, '0');
            const year = today.getFullYear();
            const altFormat = `${month}/${day}/${year}`;
            todayIndex = labels.findIndex(label => label === altFormat);
            console.log('Trying alternate format:', altFormat);
        }

        // Method 3: If still not found, find the closest date
        if (todayIndex === -1) {
            const todayTime = today.getTime();
            let closestDiff = Infinity;

            labels.forEach((label, index) => {
                try {
                    // Try to parse the date
                    let labelDate;
                    if (label.includes('/')) {
                        const parts = label.split('/');
                        if (parts.length === 3) {
                            // MM/DD/YYYY format
                            labelDate = new Date(parts[2], parts[0] - 1, parts[1]);
                        }
                    } else {
                        labelDate = new Date(label);
                    }

                    if (!isNaN(labelDate.getTime())) {
                        const diff = Math.abs(labelDate.getTime() - todayTime);
                        if (diff < closestDiff) {
                            closestDiff = diff;
                            todayIndex = index;
                        }
                    }
                } catch (e) {
                    // Skip invalid dates
                }
            });

            console.log('Found closest date at index:', todayIndex);
        }

        // Create annotations for current day indicator and target weight
        const annotations = {};

        // 1. Today's date indicator
        if (todayIndex !== -1) {
            // Today's date is in our chart labels
            annotations.todayLine = {
                type: 'line',
                xMin: todayIndex,
                xMax: todayIndex,
                borderColor: '#2ecc71', // Green color for today's line
                borderWidth: 3,
                borderDash: [6, 6],
                label: {
                    display: true,
                    content: 'TODAY',
                    position: 'start',
                    backgroundColor: '#2ecc71',
                    color: '#fff',
                    font: {
                        weight: 'bold',
                        size: 14
                    },
                    padding: 6
                }
            };

            console.log(`Today indicator added at index ${todayIndex} (${labels[todayIndex]})`);
        } else {
            // If we still can't find today, add indicator at the last actual data point
            let lastDataIndex = -1;
            for (let i = actualData.length - 1; i >= 0; i--) {
                if (actualData[i] !== null) {
                    lastDataIndex = i;
                    break;
                }
            }

            if (lastDataIndex !== -1) {
                annotations.todayLine = {
                    type: 'line',
                    xMin: lastDataIndex,
                    xMax: lastDataIndex,
                    borderColor: '#2ecc71', // Green color for today's line
                    borderWidth: 3,
                    borderDash: [6, 6],
                    label: {
                        display: true,
                        content: 'TODAY (approx)',
                        position: 'start',
                        backgroundColor: '#2ecc71',
                        color: '#fff',
                        font: {
                            weight: 'bold',
                            size: 14
                        },
                        padding: 6
                    }
                };

                console.log(`Today indicator added at last data point: ${lastDataIndex}`);
            } else {
                console.log('Could not find a suitable position for today indicator');
            }
        }

        // 2. Target weight indicator - horizontal line across the chart
        if (targetData && targetData.length > 0 && targetWeight) {
            // Make sure targetWeight is a number
            let targetWeightValue = parseFloat(targetWeight);

            if (!isNaN(targetWeightValue)) {
                annotations.targetWeightLine = {
                    type: 'line',
                    yMin: targetWeightValue,
                    yMax: targetWeightValue,
                    borderColor: '#9b59b6', // Purple color for target weight
                    borderWidth: 2,
                    borderDash: [5, 5],
                    label: {
                        display: true,
                        content: `TARGET: ${targetWeightValue.toFixed(2)} lbs`,
                        position: 'end',
                        backgroundColor: '#9b59b6',
                        color: '#fff',
                        font: {
                            weight: 'bold',
                            size: 14
                        },
                        padding: 6
                    }
                };

                // 3. Add a box highlight around the target weight area
                const buffer = 3; // Buffer zone of 3 pounds around target
                annotations.targetZone = {
                    type: 'box',
                    yMin: targetWeightValue - buffer,
                    yMax: targetWeightValue + buffer,
                    backgroundColor: 'rgba(155, 89, 182, 0.1)', // Light purple background
                    borderColor: 'rgba(155, 89, 182, 0.3)',
                    borderWidth: 1,
                    drawTime: 'beforeDatasetsDraw' // Draw behind the data
                };

                console.log(`Target weight indicator added at ${targetWeightValue} lbs`);
            } else {
                console.log('Could not parse target weight value');
            }
        }

        // Make sure the annotation plugin is registered before creating the chart
        try {
            // Check if annotation plugin is available
            let annotationPluginAvailable = false;

            if (Chart.registry && Chart.registry.plugins) {
                const plugins = Object.values(Chart.registry.plugins.items);
                annotationPluginAvailable = plugins.some(p => p.id === 'annotation');
            }

            if (!annotationPluginAvailable) {
                console.warn('Annotation plugin not found in registry, trying to register manually');

                // Try global ChartAnnotation
                if (typeof ChartAnnotation !== 'undefined') {
                    Chart.register(ChartAnnotation);
                    console.log('Registered annotation plugin from global ChartAnnotation');
                }
                // Try Chart.Annotation
                else if (Chart.Annotation) {
                    Chart.register(Chart.Annotation);
                    console.log('Registered annotation plugin from Chart.Annotation');
                }
            }
        } catch (error) {
            console.error('Error checking/registering annotation plugin:', error);
        }

        // Find the minimum and maximum weights for better scaling
        const validWeights = actualData.filter(w => w !== null && w !== undefined);

        // Add significant buffer below the minimum to ensure points don't go below the view
        const minWeight = Math.min(...validWeights) * 0.90; // 10% buffer below min
        const maxWeight = Math.max(...validWeights) * 1.05; // 5% buffer above max

        // If we have a target weight, include it in the scale calculation
        let yMin = minWeight;
        let yMax = maxWeight;

        if (targetWeight && !isNaN(targetWeight)) {
            // If target weight is higher than current weights, add more buffer
            if (targetWeight > maxWeight) {
                yMax = targetWeight * 1.05; // 5% buffer above target
            } else if (targetWeight < minWeight) {
                yMin = targetWeight * 0.90; // 10% buffer below target
            } else {
                yMin = Math.min(yMin, targetWeight * 0.90);
                yMax = Math.max(yMax, targetWeight * 1.05);
            }
        }

        // Add extra padding to ensure points are fully visible
        const range = yMax - yMin;
        yMin -= range * 0.15; // Additional 15% padding at bottom
        yMax += range * 0.05; // Additional 5% padding at top

        // Ensure there's always a minimum visible range, even with high zoom
        const minVisibleRange = Math.max(...validWeights) * 0.1; // At least 10% of max weight
        if ((yMax - yMin) < minVisibleRange) {
            yMin = yMax - minVisibleRange;
        }

        // Create the chart configuration
        const chartConfig = {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets
            },
            plugins: [{
                id: 'customCanvasBackgroundColor',
                beforeDraw: (chart) => {
                    // Clear the canvas completely before drawing
                    const ctx = chart.canvas.getContext('2d');
                    ctx.save();
                    ctx.globalCompositeOperation = 'destination-over';
                    ctx.fillStyle = 'rgba(20, 20, 20, 0.8)'; // Dark background color
                    ctx.fillRect(0, 0, chart.width, chart.height);
                    ctx.restore();
                }
            }, {
                id: 'customGoalWeightPoints',
                afterDraw: function(chart) {
                    // Add classes to goal weight points for selection
                    if (chart.getDatasetMeta(1) && chart.getDatasetMeta(1).data) {
                        const goalPoints = chart.getDatasetMeta(1).data;

                        // Store weekly increment dates for custom goal weights
                        window.weeklyIncrementDates = [];

                        goalPoints.forEach((point, index) => {
                            // Check if this is a weekly increment point
                            if (window.weeklyGoalWeights && window.weeklyGoalWeights.length > 0) {
                                const weeklyPoint = window.weeklyGoalWeights.find(w => w.index === index);

                                if (weeklyPoint) {
                                    // Add class for selection
                                    if (point.element) {
                                        point.element.classList.add('goal-weight-point');
                                        point.element.dataset.weekNumber = weeklyPoint.week;
                                    }

                                    // Store the date for this week number
                                    window.weeklyIncrementDates[weeklyPoint.week] = weeklyPoint.date;
                                }
                            }
                        });

                        // Call the addWeekNumbers function if available
                        if (window.customGoalWeights && typeof window.customGoalWeights.addWeekNumbers === 'function') {
                            window.customGoalWeights.addWeekNumbers();
                        }
                    }
                }
            }],
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'point',
                    intersect: true,
                    axis: 'xy'
                },
                parsing: {
                    xAxisKey: 'x',
                    yAxisKey: 'y'
                },
                // Add layout configuration to ensure proper padding
                layout: {
                    padding: {
                        left: 15,
                        right: 15,
                        top: 10,
                        bottom: 10
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false, // Don't force y-axis to start at 0 for weight
                        title: {
                            display: true,
                            text: 'Weight (lbs)',
                            color: '#e0e0e0', // Light text color for dark theme
                            font: {
                                weight: 'bold',
                                size: 14
                            },
                            padding: { top: 0, bottom: 10 } // Add padding to title
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)',
                            borderColor: 'rgba(255, 255, 255, 0.2)'
                        },
                        ticks: {
                            color: '#e0e0e0', // Light text color for dark theme
                            font: {
                                size: 12
                            },
                            callback: function(value) {
                                // Round to 2 decimal places for y-axis labels
                                return parseFloat(value).toFixed(2) + ' lbs';
                            },
                            padding: 15, // Increased padding to ensure ticks don't get cut off
                            // Ensure we don't have too many ticks
                            maxTicksLimit: 10
                        },
                        // Add reasonable defaults for the y-axis
                        grace: '5%', // Add 5% padding to the scale
                        // Ensure the axis adapts to the data
                        adapters: {
                            date: false
                        },
                        // Set fixed min/max values to prevent scaling issues
                        min: yMin,
                        max: yMax,
                        // Ensure the axis doesn't get cut off
                        position: 'left',
                        // Add extra space to prevent overlap with y-axis labels
                        afterFit: function(scaleInstance) {
                            // Add extra width to ensure labels are fully visible
                            scaleInstance.width = Math.max(scaleInstance.width, 80);
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Date',
                            color: '#e0e0e0', // Light text color for dark theme
                            font: {
                                weight: 'bold',
                                size: 14
                            },
                            padding: { top: 10, bottom: 0 } // Add padding to title
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)',
                            borderColor: 'rgba(255, 255, 255, 0.2)'
                        },
                        // Apply the x-axis scale factor by controlling how many ticks/labels are shown
                        ticks: {
                            color: '#e0e0e0', // Light text color for dark theme
                            maxRotation: 45,
                            minRotation: 45,
                            font: {
                                size: 11
                            },
                            // Control the number of ticks based on the scale factor
                            // Lower xAxisScale = more ticks (compressed view showing more dates)
                            // Higher xAxisScale = fewer ticks (expanded view showing fewer dates)
                            autoSkip: true,
                            autoSkipPadding: 15, // Increased padding between ticks
                            maxTicksLimit: Math.max(5, Math.round(20 / xAxisScale)),
                            padding: 10 // Add padding to ensure ticks don't get cut off
                        },
                        // Enable zooming on the x-axis
                        min: 0,
                        max: labels.length - 1,
                        // Ensure the axis doesn't get cut off
                        offset: true, // Add offset to prevent labels from being cut off
                        // Add extra space to prevent overlap with x-axis labels
                        afterFit: function(scaleInstance) {
                            // Add extra height to ensure labels are fully visible
                            scaleInstance.height = Math.max(scaleInstance.height, 60);
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#e0e0e0', // Light text color for dark theme
                            font: {
                                size: 14
                            },
                            usePointStyle: true,
                            padding: 20
                        }
                    },
                    tooltip: {
                        enabled: false // Disable built-in tooltips, we'll use our own
                    },
                    // Custom plugin for tooltips
                    customTooltips: {
                        callbacks: {
                            title: function(tooltipItems) {
                                // Format the date in the tooltip title
                                if (tooltipItems.length > 0) {
                                    const label = tooltipItems[0].label;
                                    const pointIndex = tooltipItems[0].dataIndex;

                                    // Special case for the first weekly goal weight point (week 0)
                                    // This ensures the tooltip always shows May 6, 2024 for the first point
                                    if (window.weeklyGoalWeights && window.weeklyGoalWeights.length > 0) {
                                        // First check if this is exactly the first weekly point
                                        const weeklyPoint = window.weeklyGoalWeights.find(w => w.index === pointIndex && w.week === 0);
                                        if (weeklyPoint) {
                                            // Force the first weekly point to be May 6, 2024
                                            console.log("Forcing first weekly point date to May 6, 2024 in chart tooltip");
                                            return "May 6, 2024";
                                        }

                                        // Also check if this is the index that should correspond to May 6, 2024
                                        // This handles cases where the point might not be properly tagged
                                        const firstWeeklyPointIndex = window.weeklyIncrementDates.find(w => w.week === 0)?.index;
                                        if (firstWeeklyPointIndex === pointIndex) {
                                            console.log("Forcing date to May 6, 2024 based on index match");
                                            return "May 6, 2024";
                                        }
                                    }

                                    try {
                                        // Try to parse and format the date
                                        const date = new Date(label);
                                        if (!isNaN(date.getTime())) {
                                            // Format as Month Day, Year (e.g., April 4, 2025)
                                            return date.toLocaleDateString('en-US', {
                                                month: 'long',
                                                day: 'numeric',
                                                year: 'numeric'
                                            });
                                        }
                                    } catch (e) {
                                        // If parsing fails, return the original label
                                    }
                                    return label;
                                }
                                return '';
                            },
                            label: function(context) {
                                try {
                                    // First, check if we have valid data
                                    if (!context || !context.parsed || context.parsed.y === null || context.parsed.y === undefined) {
                                        return 'No data available';
                                    }

                                    // Get the weight value regardless of dataset type
                                    const weightValue = parseFloat(context.parsed.y).toFixed(2);

                                    // Check dataset type by label if available
                                    const datasetLabel = context.dataset.label || '';

                                    if (datasetLabel.includes('Actual')) {
                                        return `Weight: ${weightValue} lbs`;
                                    } else if (datasetLabel.includes('Goal')) {
                                        return `Goal: ${weightValue} lbs`;
                                    } else {
                                        // Fallback for any dataset
                                        return `Value: ${weightValue} lbs`;
                                    }
                                } catch (error) {
                                    console.error('Error in tooltip label callback:', error);
                                    return 'Error displaying data';
                                }
                            },
                            // Add afterLabel to show additional information
                            afterLabel: function(context) {
                                try {
                                    // First, check if we have valid data
                                    if (!context || !context.parsed || context.parsed.y === null || context.parsed.y === undefined) {
                                        return null;
                                    }

                                    const datasetLabel = context.dataset.label || '';

                                    // Only add this for actual weight points
                                    if (datasetLabel.includes('Actual')) {
                                        // If we have a target weight, show the difference
                                        if (targetWeight && !isNaN(targetWeight)) {
                                            const diff = context.parsed.y - targetWeight;
                                            const sign = diff >= 0 ? '+' : '';
                                            return `${sign}${diff.toFixed(2)} lbs from target`;
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error in tooltip afterLabel callback:', error);
                                }
                                return null;
                            }
                        }
                    }
                }
            }
        };

        // Temporarily disable annotations to prevent errors
        console.log('Annotations disabled to prevent errors');
        // We'll use simple lines instead of the annotation plugin

        // Set better default Y-axis range before creating the chart
        // Find min and max values in the actual data
        let minValue = Number.MAX_VALUE;
        let maxValue = Number.MIN_VALUE;

        formattedActualData.forEach(point => {
            if (point.y !== null && !isNaN(point.y)) {
                minValue = Math.min(minValue, point.y);
                maxValue = Math.max(maxValue, point.y);
            }
        });

        // Add target weight to the range calculation if available
        if (targetWeight && !isNaN(targetWeight)) {
            minValue = Math.min(minValue, targetWeight);
            maxValue = Math.max(maxValue, targetWeight);
        }

        // If we have valid min/max values, set a reasonable range
        if (minValue !== Number.MAX_VALUE && maxValue !== Number.MIN_VALUE) {
            // Calculate a reasonable padding (about 5% of the range)
            const range = maxValue - minValue;
            const padding = Math.max(range * 0.05, 2); // At least 2 lbs padding

            // Set the min/max with padding
            chartConfig.options.scales.y.min = Math.max(0, minValue - padding);
            chartConfig.options.scales.y.max = maxValue + padding;

            console.log(`Setting initial Y-axis range: ${chartConfig.options.scales.y.min} to ${chartConfig.options.scales.y.max}`);
        }

        // Store target weight in chart options for tooltip access
        chartConfig.options.targetWeight = parseFloat(targetWeight);
        console.log('Setting target weight in chart options:', chartConfig.options.targetWeight);

        // Create the chart
        weightGoalChart = new Chart(ctx, chartConfig);
        weightGoalChart._initialScaleApplied = false; // Mark as needing initial scale

        // Attach custom tooltip events
        if (window.attachWeightChartTooltipEvents) {
            window.attachWeightChartTooltipEvents(weightGoalChart);
        } else {
            console.error('Custom tooltip functions not available');
        }

        // Initialize the chart with the current y-axis scale
        // This ensures the scale is applied correctly on initial load
        setTimeout(() => {
            if (weightGoalChart && typeof updateChartYAxisScale === 'function') {
                // Force scale to 1.0 for initial render
                updateChartYAxisScale(weightGoalChart, 1.0, false);
                console.log('Applied initial y-axis scale: 1.0x');

                // Reset the sliders to 1.0
                if (xAxisScaleSlider) xAxisScaleSlider.value = 1.0;
                if (yAxisScaleSlider) yAxisScaleSlider.value = 1.0;
                if (xScaleValue) xScaleValue.textContent = '1.0x';
                if (yScaleValue) yScaleValue.textContent = '1.0x';
                xAxisScale = 1.0;
                yAxisScale = 1.0;
            }
        }, 100);
    }

    // --- Recipe Loading and Display --- //

    // Function to load recipes with retry mechanism
    async function loadRecipes(retryCount = 0, maxRetries = 3) {
        console.log(`Loading recipes... (attempt ${retryCount + 1} of ${maxRetries + 1})`);
        showStatus(recipesDisplayStatus, 'Loading recipes...', 'info');

        // Show loading indicator in the recipe list container
        recipeListContainer.innerHTML = `
            <div style="text-align:center; padding: 20px;">
                <p>Loading recipes...</p>
                <div class="loading-spinner" style="
                    display: inline-block;
                    width: 30px;
                    height: 30px;
                    border: 3px solid rgba(255,255,255,.3);
                    border-radius: 50%;
                    border-top-color: #fff;
                    animation: spin 1s ease-in-out infinite;
                "></div>
            </div>
            <style>
                @keyframes spin {
                    to { transform: rotate(360deg); }
                }
            </style>
        `;

        try {
            // Add cache-busting query parameter with a random component
            const timestamp = new Date().getTime();
            const random = Math.floor(Math.random() * 1000000);
            const url = `/api/recipes?timestamp=${timestamp}&random=${random}`;
            console.log(`Fetching recipes from: ${url}`);

            // Force browser to bypass cache completely
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                },
                cache: 'no-store' // Force fetch to bypass cache
            });

            console.log('Response status:', response.status);
            console.log('Response headers:', Object.fromEntries([...response.headers.entries()]));

            if (!response.ok) {
                const errorText = await response.text();
                console.error('Error response:', errorText);
                throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
            }

            const responseText = await response.text();
            console.log('Raw response text:', responseText);

            // Check if the response is empty
            if (!responseText.trim()) {
                console.error('Empty response received');
                throw new Error('Empty response from server');
            }

            let recipes;
            try {
                recipes = JSON.parse(responseText);
                console.log(`Loaded ${recipes.length} recipes:`, recipes);
            } catch (jsonError) {
                console.error('Error parsing JSON:', jsonError);
                console.error('Response text that failed to parse:', responseText);
                throw new Error(`Failed to parse recipe data: ${jsonError.message}`);
            }

            if (!Array.isArray(recipes)) {
                console.error('Recipes is not an array:', recipes);
                throw new Error('Invalid recipe data: expected an array');
            }

            renderRecipes(recipes);
            showStatus(recipesDisplayStatus, '', ''); // Clear status on success

            // Show success notification if this was a retry
            if (retryCount > 0) {
                // Create a popup notification
                const notification = document.createElement('div');
                notification.className = 'recipes-loaded-notification';
                notification.innerHTML = `
                    <div class="recipes-loaded-notification-content">
                        <span class="recipes-loaded-notification-icon">✓</span>
                        <span class="recipes-loaded-notification-text">Recipes loaded successfully!</span>
                    </div>
                `;
                document.body.appendChild(notification);

                // Add styles for the notification
                const style = document.createElement('style');
                style.textContent = `
                    .recipes-loaded-notification {
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        background-color: #000;
                        color: white;
                        padding: 15px 20px;
                        border-radius: 5px;
                        z-index: 9999;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.5);
                        border-left: 4px solid #00ff00;
                        animation: slideIn 0.5s forwards;
                    }
                    .recipes-loaded-notification-content {
                        display: flex;
                        align-items: center;
                    }
                    .recipes-loaded-notification-icon {
                        color: #00ff00;
                        font-size: 20px;
                        margin-right: 10px;
                    }
                    .recipes-loaded-notification-text {
                        font-size: 16px;
                    }
                    @keyframes slideIn {
                        from { transform: translateX(100%); }
                        to { transform: translateX(0); }
                    }
                `;
                document.head.appendChild(style);

                // Remove the notification after 3 seconds
                setTimeout(() => {
                    notification.remove();
                    style.remove();
                }, 3000);
            }

        } catch (error) {
            console.error('Error loading recipes:', error);

            // Retry logic
            if (retryCount < maxRetries) {
                console.log(`Retrying in ${(retryCount + 1) * 1000}ms...`);
                showStatus(recipesDisplayStatus, `Retrying to load recipes (${retryCount + 1}/${maxRetries})...`, 'info');

                // Wait before retrying, with increasing delay
                await new Promise(resolve => setTimeout(resolve, (retryCount + 1) * 1000));

                // Retry with incremented counter
                return loadRecipes(retryCount + 1, maxRetries);
            }

            // All retries failed, show error and try alternative approach
            showStatus(recipesDisplayStatus, `Failed to load recipes: ${error.message}`, 'error');
            recipeListContainer.innerHTML = `
                <div style="text-align:center; padding: 20px; color: red;">
                    <p>Could not load recipes: ${error.message}</p>
                    <button id="retry-load-recipes" style="
                        background-color: #000;
                        color: white;
                        border: 1px solid white;
                        padding: 8px 15px;
                        margin-top: 10px;
                        cursor: pointer;
                    ">Retry Loading Recipes</button>
                </div>
            `;

            // Add event listener to retry button
            document.getElementById('retry-load-recipes').addEventListener('click', () => {
                loadRecipes(0, maxRetries); // Reset retry count
            });

            // Try alternative approach
            try {
                console.log('Trying alternative approach to load recipes...');

                // Use XMLHttpRequest as an alternative to fetch
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/api/recipes', true);
                xhr.setRequestHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
                xhr.setRequestHeader('Pragma', 'no-cache');
                xhr.setRequestHeader('Expires', '0');

                xhr.onload = function() {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        console.log('XHR response received:', xhr.responseText);
                        try {
                            const recipes = JSON.parse(xhr.responseText);
                            console.log(`Alternative approach loaded ${recipes.length} recipes`);
                            renderRecipes(recipes);
                            showStatus(recipesDisplayStatus, '', ''); // Clear status on success
                        } catch (jsonError) {
                            console.error('Error parsing JSON from XHR:', jsonError);
                            console.error('XHR response text:', xhr.responseText);
                        }
                    } else {
                        console.error('XHR request failed with status:', xhr.status);
                        console.error('XHR response:', xhr.responseText);
                    }
                };

                xhr.onerror = function() {
                    console.error('XHR network error');
                };

                xhr.send();

            } catch (retryError) {
                console.error('Alternative approach also failed:', retryError);
            }
        }
    }

    function renderRecipes(recipes) {
        recipeListContainer.innerHTML = ''; // Clear previous list

        if (recipes.length === 0) {
            recipeListContainer.innerHTML = '<p style="text-align:center;">No recipes found. Create one above!</p>';
            return;
        }

        recipes.forEach(recipe => {
            const recipeDiv = document.createElement('div');
            recipeDiv.classList.add('recipe-card'); // Use new compact card class
            recipeDiv.dataset.id = recipe.id;

            recipeDiv.innerHTML = `
                <div class="recipe-card-header">
                    <h3 class="recipe-card-title">${escapeHtml(recipe.name)}</h3>
                    <div class="recipe-card-actions">
                        <button type="button" class="recipe-card-btn primary view-ingredients-btn">View</button>
                        <button type="button" class="recipe-card-btn adjust-calories-toggle">Adjust</button>
                        <button type="button" class="recipe-card-btn danger delete-recipe-btn">Delete</button>
                    </div>
                    <p class="recipe-card-calories">${recipe.total_calories.toFixed(1)} calories</p>
                </div>

                <div class="recipe-card-body">

                    <!-- Compact Calorie Adjustment Controls (initially hidden) -->
                    <div class="calorie-adjustment-compact" style="display: none;">
                        <!-- Top row with input and set button -->
                        <div class="input-row">
                            <div class="input-container">
                                <input type="number" class="target-calories-input" placeholder="New Cal Total" step="1">
                            </div>
                            <button type="button" class="set-btn adjust-calories-btn">Set</button>
                        </div>

                        <!-- New layout for adjustment buttons -->
                        <div class="adjustment-buttons-row">
                            <!-- Percentage adjustments (left side of input) -->
                            <div class="percent-adjustments">
                                <button type="button" class="recipe-card-btn adjust-calories-percent-btn" data-percent="0.75">-25%</button>
                                <button type="button" class="recipe-card-btn adjust-calories-percent-btn" data-percent="1.25">+25%</button>
                            </div>

                            <!-- Flat adjustments (right side of input) -->
                            <div class="flat-adjustments">
                                <button type="button" class="recipe-card-btn adjust-calories-amount-btn" data-amount="-200">-200</button>
                                <button type="button" class="recipe-card-btn adjust-calories-amount-btn" data-amount="200">+200</button>
                            </div>
                        </div>
                    </div>

                    <div class="ingredient-details" style="display: none;">
                        <!-- Ingredient details will be loaded here -->
                    </div>
                    <div class="adjustment-status status"></div> <!-- Status for adjustments -->
                </div>
            `;
            recipeListContainer.appendChild(recipeDiv);

            // Add toggle functionality for the adjust calories section
            const adjustToggleBtn = recipeDiv.querySelector('.adjust-calories-toggle');
            const adjustSection = recipeDiv.querySelector('.calorie-adjustment-compact');

            if (adjustToggleBtn && adjustSection) {
                adjustToggleBtn.addEventListener('click', function() {
                    const isVisible = adjustSection.style.display !== 'none';
                    adjustSection.style.display = isVisible ? 'none' : 'grid';
                    adjustToggleBtn.textContent = isVisible ? 'Adjust' : 'Hide';
                });
            }
        });
    }

    // --- Recipe Deletion --- //

    async function deleteRecipe(id) {
        if (!confirm('Are you sure you want to delete this recipe and all its ingredients?')) {
            return;
        }
        showStatus(recipesDisplayStatus, `Deleting recipe ${id}...`, 'info');
        try {
            const response = await fetch(`/api/recipes/${id}`, {
                method: 'DELETE'
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
            const result = await response.json();
            showStatus(recipesDisplayStatus, result.message || 'Recipe deleted successfully', 'success');
            loadRecipes(); // Refresh the list
        } catch (error) {
            console.error('Error deleting recipe:', error);
            showStatus(recipesDisplayStatus, `Error deleting recipe: ${error.message}`, 'error');
        }
    }

    // --- Utility Functions --- //

    function showStatus(element, message, type) {
        if (!element) return;
        element.textContent = message;
        element.className = `status ${type}`;
        if (type !== 'info') {
            setTimeout(() => {
                if (element.textContent === message) { // Clear only if message hasn't changed
                     element.textContent = '';
                     element.className = 'status';
                }
            }, 5000);
        }
    }

    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return unsafe; // Handle non-strings
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    // --- Calorie Adjustment Logic --- //
    async function adjustRecipeCalories(recipeId, targetCalories, recipeItemElement) {
        const statusElement = recipeItemElement.querySelector('.adjustment-status');
        showStatus(statusElement, 'Adjusting calories...', 'info');

        if (isNaN(targetCalories) || targetCalories <= 0) {
            showStatus(statusElement, 'Invalid target calorie value.', 'error');
            return;
        }

        try {
            const response = await fetch(`/api/recipes/${recipeId}`,
             {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ targetCalories: targetCalories })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }

            const updatedRecipe = await response.json();

            // Update the displayed calories
            const caloriesSpan = recipeItemElement.querySelector('.recipe-card-calories');
            if (caloriesSpan) {
                caloriesSpan.textContent = `${updatedRecipe.total_calories.toFixed(1)} calories`;
            }
            // Clear target input
            const targetInput = recipeItemElement.querySelector('.target-calories-input');
            if(targetInput) targetInput.value = '';

            // Update the ingredient details if they are currently displayed
            const detailsDiv = recipeItemElement.querySelector('.ingredient-details');
            if (detailsDiv.style.display !== 'none') {
                 renderIngredientDetails(updatedRecipe.ingredients, detailsDiv);
            }

            showStatus(statusElement, 'Calories adjusted successfully!', 'success');

        } catch (error) {
            console.error('Error adjusting calories:', error);
            showStatus(statusElement, `Error: ${error.message}`, 'error');
        }
    }

    // --- View Ingredients Logic --- //
    async function fetchAndDisplayIngredients(recipeId, detailsDiv, viewButton, forceRefresh = false) {
        console.log(`=== fetchAndDisplayIngredients called for recipe ${recipeId}${forceRefresh ? ' (FORCE REFRESH)' : ''} ===`);

        // Set force refresh flag if passed as parameter
        if (forceRefresh) {
            console.log('Force refresh parameter detected - will refresh ingredients');
            detailsDiv.dataset.forceRefresh = 'true';
        }

        // Validate inputs
        if (!recipeId) {
            console.error('Recipe ID is required for fetchAndDisplayIngredients');
            return;
        }

        if (!detailsDiv) {
            console.error('Details div is required for fetchAndDisplayIngredients');
            return;
        }

        // Toggle visibility unless force refresh is set
        if (detailsDiv.style.display !== 'none' && !detailsDiv.dataset.forceRefresh) {
            console.log('Toggling visibility - hiding ingredients');
            detailsDiv.style.display = 'none';
            detailsDiv.innerHTML = ''; // Clear content
            if (viewButton) {
                viewButton.textContent = 'View';
                viewButton.classList.remove('active');
            }
            return;
        }

        // Clear the force refresh flag if it was set
        if (detailsDiv.dataset.forceRefresh) {
            console.log('Force refresh flag detected - will refresh ingredients');
            delete detailsDiv.dataset.forceRefresh;
        }

        // Show loading indicator
        detailsDiv.innerHTML = '<p>Loading ingredients...</p>';
        detailsDiv.style.display = 'block';
        if (viewButton) {
            viewButton.textContent = 'Hide';
            viewButton.classList.add('active');
        }

        try {
            // Add cache-busting query parameter to ensure we get the latest data
            const timestamp = new Date().getTime();
            console.log(`Fetching recipe data with timestamp ${timestamp}`);

            // Make the API request with explicit no-cache headers
            const response = await fetch(`/api/recipes/${recipeId}?timestamp=${timestamp}`, {
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            });

            console.log('API response status:', response.status);

            if (!response.ok) {
                let errorMessage = `Server returned ${response.status} ${response.statusText}`;
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.error || errorMessage;
                    console.error('Server error response:', errorData);
                } catch (jsonError) {
                    console.error('Could not parse error response as JSON:', jsonError);
                }
                throw new Error(errorMessage);
            }

            const recipeData = await response.json();

            // Log the recipe data to help debug
            console.log('Fetched recipe data:', recipeData);
            console.log(`Fetched ${recipeData.ingredients ? recipeData.ingredients.length : 0} ingredients`);

            // Verify we have ingredients
            if (!recipeData.ingredients || !Array.isArray(recipeData.ingredients)) {
                console.error('No ingredients array in recipe data:', recipeData);
                throw new Error('No ingredients found in recipe data');
            }

            if (recipeData.ingredients.length === 0) {
                console.warn('Recipe has no ingredients');
                detailsDiv.innerHTML = '<p>This recipe has no ingredients.</p>';
                return;
            }

            // Check if any ingredients have package_amount
            recipeData.ingredients.forEach(ing => {
                console.log(`Ingredient ${ing.id} (${ing.name}) has package_amount:`, ing.package_amount, typeof ing.package_amount);
            });

            // Render ingredients with a responsive approach
            console.log('Rendering ingredient details');
            renderIngredientDetails(recipeData.ingredients, detailsDiv);
            console.log('Ingredient details rendered successfully');

            // Ensure the details div is fully visible
            setTimeout(() => {
                detailsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                console.log('Scrolled to ingredient details');
            }, 100);
        } catch (error) {
            console.error('Error fetching ingredients:', error);
            detailsDiv.innerHTML = `<p style="color:red;">Error loading ingredients: ${error.message}</p>
                                    <button onclick="fetchAndDisplayIngredients('${recipeId}', this.parentElement, null)">
                                        Retry
                                    </button>`;
        }
    }

    // We now use the OmegaStorage utility for managing omega values

    function renderIngredientDetails(ingredients, container) {
        console.log('=== renderIngredientDetails called ===');
        console.log('Ingredients to render:', ingredients);

        if (!ingredients || ingredients.length === 0) {
            container.innerHTML = '<p>No ingredients found for this recipe.</p>';
            return;
        }

        // CRITICAL FIX: Force browser to recognize this is new data by adding a timestamp
        const renderTimestamp = new Date().getTime();
        console.log(`Rendering ingredients with timestamp: ${renderTimestamp}`);

        // CRITICAL FIX: Apply omega values from OmegaStorage
        if (ingredients && ingredients.length > 0 && window.OmegaStorage) {
            console.log('Applying omega values from OmegaStorage to ingredients');
            // Use the OmegaStorage utility to apply omega values to all ingredients
            ingredients = window.OmegaStorage.applyOmegaValuesToAll(ingredients);
        }

        // Log package_amount values for all ingredients
        ingredients.forEach(ing => {
            // Convert package_amount to a number if it's a string
            if (typeof ing.package_amount === 'string' && ing.package_amount.trim() !== '') {
                ing.package_amount = Number(ing.package_amount);
                console.log(`Converted package_amount for ${ing.name} from string to number:`, ing.package_amount);
            }

            console.log(`Rendering ingredient ${ing.id} (${ing.name}) package_amount:`, ing.package_amount, typeof ing.package_amount);
        });

        // Add buttons for detailed nutrition and adding ingredients
        let tableHtml = `
            <div class="nutrition-controls">
                <button type="button" class="toggle-detailed-nutrition" onclick="toggleNutritionPanel(this)">Show Detailed Nutrition</button>
                <button type="button" class="add-ingredient-to-recipe-btn">Add Ingredient</button>
            </div>
            <div class="responsive-table-container">
                <table class="ingredient-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Calories</th>
                            <th>Amount (g)</th>
                            <th>Package (g)</th>
                            <th>Protein (g)</th>
                            <th>Fat (g)</th>
                            <th>Carbs (g)</th>
                            <th>Package Price</th>
                            <th>Price/g</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
        `;

        ingredients.forEach(ing => {
            // Calculate per gram values if not already provided
            const calPerGram = ing.calories_per_gram ? ing.calories_per_gram.toFixed(2) :
                               (ing.amount > 0 ? (ing.calories / ing.amount).toFixed(2) : '0.00');
            const protPerGram = ing.protein_per_gram ? ing.protein_per_gram.toFixed(2) :
                                (ing.amount > 0 ? (ing.protein / ing.amount).toFixed(2) : '0.00');
            const fatPerGram = ing.fats_per_gram ? ing.fats_per_gram.toFixed(2) :
                              (ing.amount > 0 ? (ing.fats / ing.amount).toFixed(2) : '0.00');
            const carbPerGram = ing.carbohydrates_per_gram ? ing.carbohydrates_per_gram.toFixed(2) :
                                (ing.amount > 0 ? (ing.carbohydrates / ing.amount).toFixed(2) : '0.00');
            const pricePerGram = ing.price_per_gram ? ing.price_per_gram.toFixed(3) :
                                (ing.amount > 0 ? (ing.price / ing.amount).toFixed(3) : '0.000');

            // Debug log for package amount
            console.log(`Ingredient ${ing.name} package_amount:`, ing.package_amount, typeof ing.package_amount);

            // CRITICAL FIX: Ensure package amount is properly formatted for display
            let packageAmountDisplay = '-';

            // First check if we have a value in local storage
            let packageAmountNum = ing.package_amount;

            if (window.localStorageManager) {
                const savedPackageAmount = window.localStorageManager.getPackageAmount(ing.id);
                if (savedPackageAmount !== null) {
                    console.debug(`Found saved package amount in local storage for ingredient ${ing.id}: ${savedPackageAmount}`);
                    packageAmountNum = savedPackageAmount;
                }
            }

            // Then make sure package_amount is a number
            if (typeof packageAmountNum === 'string' && packageAmountNum.trim() !== '') {
                packageAmountNum = Number(packageAmountNum);
                console.log(`Converted string package_amount to number for ${ing.name}:`, packageAmountNum);
            }

            if (packageAmountNum !== null && packageAmountNum !== undefined) {
                if (!isNaN(packageAmountNum)) {
                    packageAmountDisplay = packageAmountNum.toFixed(1);
                    console.log(`Formatted package amount for ${ing.name}:`, packageAmountDisplay);

                    // Update the original object to ensure consistency
                    ing.package_amount = packageAmountNum;
                }
            }

            // CRITICAL FIX: Ensure package amount is properly displayed
            // Double-check the package amount value
            console.log(`Final package amount for ${ing.name} before rendering:`, ing.package_amount, typeof ing.package_amount);
            console.log(`Final display value for ${ing.name}:`, packageAmountDisplay);

            // Force refresh the package amount display by adding a timestamp to avoid browser caching
            const refreshTimestamp = new Date().getTime();

            tableHtml += `
                <tr data-ingredient-id="${ing.id}" data-recipe-id="${ing.recipe_id}">
                    <td title="${escapeHtml(ing.name)}">${escapeHtml(ing.name)}</td>
                    <td title="Calories: ${ing.calories.toFixed(1)}">${ing.calories.toFixed(1)}</td>
                    <td title="Amount: ${ing.amount.toFixed(1)}g">${ing.amount.toFixed(1)}</td>
                    <td title="Package: ${packageAmountDisplay}g" data-refresh="${refreshTimestamp}">
                        ${packageAmountDisplay}
                        <span class="refresh-timestamp" style="display:none;">${refreshTimestamp}</span>
                    </td>
                    <td title="Protein: ${ing.protein.toFixed(1)}g">${ing.protein.toFixed(1)}</td>
                    <td title="Fat: ${ing.fats.toFixed(1)}g">${ing.fats.toFixed(1)}</td>
                    <td title="Carbs: ${ing.carbohydrates.toFixed(1)}g">${ing.carbohydrates.toFixed(1)}</td>
                    <td title="Package Price: $${ing.price.toFixed(2)}">${ing.price.toFixed(2)}</td>
                    <td title="Price per gram: ${pricePerGram}">${pricePerGram}</td>
                    <td>
                        <button type="button" class="edit-ingredient-btn">Edit</button>
                    </td>
                </tr>
            `;
        });

        tableHtml += `
                </tbody>
            </table>
            <!-- Add Ingredient Form -->
            <div class="add-ingredient-form" style="display: none;">
                <h4>Add Ingredient to Recipe</h4>
                <form id="add-ingredient-form" class="ingredient-item">
                    <input type="hidden" id="add-ingredient-recipe-id" name="recipe-id">

                    <div class="compact-form-layout">
                        <!-- Top Row: Selection Type and Dropdown -->
                        <div class="selection-row">
                            <div class="selection-type">
                                <label>
                                    <input type="radio" name="ingredient-selection-type" value="existing" checked>
                                    Use existing
                                </label>
                                <label>
                                    <input type="radio" name="ingredient-selection-type" value="new">
                                    Create new
                                </label>
                            </div>

                            <!-- Existing Ingredient Selection -->
                            <div id="existing-ingredient-selection">
                                <select id="existing-ingredient-select">
                                    <option value="">Loading ingredients...</option>
                                </select>
                            </div>
                        </div>

                        <!-- Middle Row: Basic Info and Cronometer -->
                        <div class="info-row">
                            <!-- Left Column: Basic Information -->
                            <div class="basic-info-grid">
                                <div class="form-group">
                                    <label for="add-ingredient-name">Name:</label>
                                    <input type="text" id="add-ingredient-name" name="ingredient-name" required>
                                </div>
                                <div class="form-group">
                                    <label for="add-ingredient-amount">Amount (g):</label>
                                    <input type="number" id="add-ingredient-amount" name="ingredient-amount" step="0.1" min="0.1" required>
                                </div>
                                <div class="form-group">
                                    <label for="add-ingredient-package-amount">Package (g):</label>
                                    <input type="number" id="add-ingredient-package-amount" name="ingredient-package-amount" step="0.1" min="0">
                                </div>
                                <div class="form-group">
                                    <label for="add-ingredient-price">Price:</label>
                                    <input type="number" id="add-ingredient-price" name="ingredient-price" step="0.01" min="0" required>
                                </div>
                                <!-- Hidden fields for form submission -->
                                <input type="hidden" class="ingredient-calories" name="calories">
                                <input type="hidden" class="ingredient-protein" name="protein">
                                <input type="hidden" class="ingredient-fat" name="fats">
                                <input type="hidden" class="ingredient-carbs" name="carbohydrates">
                            </div>

                            <!-- Right Column: Cronometer Parser -->
                            <div class="cronometer-container">
                                <textarea class="cronometer-text-paste-area" placeholder="Paste Cronometer nutrition data here..."></textarea>
                                <button type="button" class="cronometer-parse-button" onclick="if(window.processCronometerText){window.processCronometerText(this.parentNode.querySelector('.cronometer-text-paste-area').value.trim(), this.closest('.ingredient-item'), this.parentNode.querySelector('.cronometer-parse-status'))}">Parse Nutrition</button>
                                <div class="cronometer-parse-status"></div>
                            </div>
                        </div>

                        <!-- No bottom row needed as we already have a Show Detailed Nutrition button in the table header -->
                    </div>

                    <!-- Detailed Nutrition Panel -->
                    <div class="detailed-nutrition-panel" style="display:none;">
                        <!-- General Section -->
                        <div class="nutrition-section">
                            <h4>General</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="add-ingredient-calories">Energy (kcal):</label>
                                    <input type="number" id="add-ingredient-calories" name="ingredient-calories" step="0.1" min="0" required>
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-alcohol">Alcohol (g):</label>
                                    <input type="number" id="add-ingredient-alcohol" name="ingredient-alcohol" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-caffeine">Caffeine (mg):</label>
                                    <input type="number" id="add-ingredient-caffeine" name="ingredient-caffeine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-water">Water (g):</label>
                                    <input type="number" id="add-ingredient-water" name="ingredient-water" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Carbohydrates Section -->
                        <div class="nutrition-section">
                            <h4>Carbohydrates</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="add-ingredient-carbs">Carbs (g):</label>
                                    <input type="number" id="add-ingredient-carbs" name="ingredient-carbs" step="0.1" min="0" required>
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-fiber">Fiber (g):</label>
                                    <input type="number" id="add-ingredient-fiber" name="ingredient-fiber" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-starch">Starch (g):</label>
                                    <input type="number" id="add-ingredient-starch" name="ingredient-starch" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-sugars">Sugars (g):</label>
                                    <input type="number" id="add-ingredient-sugars" name="ingredient-sugars" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-added-sugars">Added Sugars (g):</label>
                                    <input type="number" id="add-ingredient-added-sugars" name="ingredient-added-sugars" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-net-carbs">Net Carbs (g):</label>
                                    <input type="number" id="add-ingredient-net-carbs" name="ingredient-net-carbs" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Lipids Section -->
                        <div class="nutrition-section">
                            <h4>Lipids</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="add-ingredient-fats">Fat (g):</label>
                                    <input type="number" id="add-ingredient-fats" name="ingredient-fats" step="0.1" min="0" required>
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-monounsaturated">Monounsaturated (g):</label>
                                    <input type="number" id="add-ingredient-monounsaturated" name="ingredient-monounsaturated" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-polyunsaturated">Polyunsaturated (g):</label>
                                    <input type="number" id="add-ingredient-polyunsaturated" name="ingredient-polyunsaturated" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-omega3">Omega 3 (g):</label>
                                    <input type="number" id="add-ingredient-omega3" name="ingredient-omega3" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-omega6">Omega 6 (g):</label>
                                    <input type="number" id="add-ingredient-omega6" name="ingredient-omega6" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-saturated">Saturated (g):</label>
                                    <input type="number" id="add-ingredient-saturated" name="ingredient-saturated" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-trans-fat">Trans Fat (g):</label>
                                    <input type="number" id="add-ingredient-trans-fat" name="ingredient-trans-fat" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-cholesterol">Cholesterol (mg):</label>
                                    <input type="number" id="add-ingredient-cholesterol" name="ingredient-cholesterol" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Protein Section -->
                        <div class="nutrition-section">
                            <h4>Protein</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="add-ingredient-protein">Protein (g):</label>
                                    <input type="number" id="add-ingredient-protein" name="ingredient-protein" step="0.1" min="0" required>
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-cystine">Cystine (g):</label>
                                    <input type="number" id="add-ingredient-cystine" name="ingredient-cystine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-histidine">Histidine (g):</label>
                                    <input type="number" id="add-ingredient-histidine" name="ingredient-histidine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-isoleucine">Isoleucine (g):</label>
                                    <input type="number" id="add-ingredient-isoleucine" name="ingredient-isoleucine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-leucine">Leucine (g):</label>
                                    <input type="number" id="add-ingredient-leucine" name="ingredient-leucine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-lysine">Lysine (g):</label>
                                    <input type="number" id="add-ingredient-lysine" name="ingredient-lysine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-methionine">Methionine (g):</label>
                                    <input type="number" id="add-ingredient-methionine" name="ingredient-methionine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-phenylalanine">Phenylalanine (g):</label>
                                    <input type="number" id="add-ingredient-phenylalanine" name="ingredient-phenylalanine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-threonine">Threonine (g):</label>
                                    <input type="number" id="add-ingredient-threonine" name="ingredient-threonine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-tryptophan">Tryptophan (g):</label>
                                    <input type="number" id="add-ingredient-tryptophan" name="ingredient-tryptophan" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-tyrosine">Tyrosine (g):</label>
                                    <input type="number" id="add-ingredient-tyrosine" name="ingredient-tyrosine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-valine">Valine (g):</label>
                                    <input type="number" id="add-ingredient-valine" name="ingredient-valine" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Vitamins Section -->
                        <div class="nutrition-section">
                            <h4>Vitamins</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-b1">B1 (Thiamine) (mg):</label>
                                    <input type="number" id="add-ingredient-vitamin-b1" name="ingredient-vitamin-b1" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-b2">B2 (Riboflavin) (mg):</label>
                                    <input type="number" id="add-ingredient-vitamin-b2" name="ingredient-vitamin-b2" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-b3">B3 (Niacin) (mg):</label>
                                    <input type="number" id="add-ingredient-vitamin-b3" name="ingredient-vitamin-b3" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-b5">B5 (Pantothenic Acid) (mg):</label>
                                    <input type="number" id="add-ingredient-vitamin-b5" name="ingredient-vitamin-b5" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-b6">B6 (Pyridoxine) (mg):</label>
                                    <input type="number" id="add-ingredient-vitamin-b6" name="ingredient-vitamin-b6" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-b12">B12 (Cobalamin) (µg):</label>
                                    <input type="number" id="add-ingredient-vitamin-b12" name="ingredient-vitamin-b12" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-folate">Folate (µg):</label>
                                    <input type="number" id="add-ingredient-folate" name="ingredient-folate" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-a">Vitamin A (µg):</label>
                                    <input type="number" id="add-ingredient-vitamin-a" name="ingredient-vitamin-a" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-c">Vitamin C (mg):</label>
                                    <input type="number" id="add-ingredient-vitamin-c" name="ingredient-vitamin-c" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-d">Vitamin D (IU):</label>
                                    <input type="number" id="add-ingredient-vitamin-d" name="ingredient-vitamin-d" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-e">Vitamin E (mg):</label>
                                    <input type="number" id="add-ingredient-vitamin-e" name="ingredient-vitamin-e" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-vitamin-k">Vitamin K (µg):</label>
                                    <input type="number" id="add-ingredient-vitamin-k" name="ingredient-vitamin-k" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Minerals Section -->
                        <div class="nutrition-section">
                            <h4>Minerals</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="add-ingredient-calcium">Calcium (mg):</label>
                                    <input type="number" id="add-ingredient-calcium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-copper">Copper (mg):</label>
                                    <input type="number" id="add-ingredient-copper" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-iron">Iron (mg):</label>
                                    <input type="number" id="add-ingredient-iron" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-magnesium">Magnesium (mg):</label>
                                    <input type="number" id="add-ingredient-magnesium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-manganese">Manganese (mg):</label>
                                    <input type="number" id="add-ingredient-manganese" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-phosphorus">Phosphorus (mg):</label>
                                    <input type="number" id="add-ingredient-phosphorus" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-potassium">Potassium (mg):</label>
                                    <input type="number" id="add-ingredient-potassium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-selenium">Selenium (µg):</label>
                                    <input type="number" id="add-ingredient-selenium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-sodium">Sodium (mg):</label>
                                    <input type="number" id="add-ingredient-sodium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-zinc">Zinc (mg):</label>
                                    <input type="number" id="add-ingredient-zinc" step="0.01" min="0">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="form-actions">
                        <button type="submit" class="save-add-ingredient-btn">Add Ingredient</button>
                        <button type="button" class="cancel-add-btn">Cancel</button>
                    </div>
                </form>
                <div class="add-ingredient-status status"></div>
            </div>

            <!-- Edit Ingredient Form -->
            <div class="edit-ingredient-form" style="display: none;">
                <h4>Edit Ingredient</h4>
                <form id="edit-ingredient-form" class="ingredient-item">
                    <input type="hidden" id="edit-ingredient-id">
                    <input type="hidden" id="edit-recipe-id">
                    <!-- Hidden fields for form submission -->
                    <input type="hidden" class="ingredient-calories">
                    <input type="hidden" class="ingredient-protein">
                    <input type="hidden" class="ingredient-fat">
                    <input type="hidden" class="ingredient-carbs">

                    <!-- Basic Information -->
                    <div class="compact-form-layout">
                        <!-- Left Column: Basic Information -->
                        <div class="basic-info-grid">
                            <div class="form-group">
                                <label for="edit-ingredient-name">Name:</label>
                                <input type="text" id="edit-ingredient-name" required>
                            </div>
                            <div class="form-group">
                                <label for="edit-ingredient-amount">Amount (g):</label>
                                <input type="number" id="edit-ingredient-amount" step="0.1" min="0.1" required>
                            </div>
                            <div class="form-group">
                                <label for="edit-ingredient-package-amount">Package (g):</label>
                                <input type="number" id="edit-ingredient-package-amount" step="0.1" min="0">
                            </div>
                            <div class="form-group">
                                <label for="edit-ingredient-price">Price:</label>
                                <input type="number" id="edit-ingredient-price" step="0.01" min="0" required>
                            </div>
                        </div>

                        <!-- Right Column: Cronometer Parser -->
                        <div class="cronometer-container">
                            <textarea class="cronometer-text-paste-area" placeholder="Paste Cronometer nutrition data here..."></textarea>
                            <button type="button" class="cronometer-parse-button" onclick="if(window.processCronometerText){window.processCronometerText(this.parentNode.querySelector('.cronometer-text-paste-area').value.trim(), this.closest('.ingredient-item'), this.parentNode.querySelector('.cronometer-parse-status'))}">Parse Nutrition</button>
                            <div class="cronometer-parse-status"></div>
                        </div>
                    </div>

                    <!-- Detailed Nutrition Panel -->
                    <div class="detailed-nutrition-panel" style="display:block;">
                        <!-- General Section -->
                        <div class="nutrition-section">
                            <h4>General</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-calories">Energy (kcal):</label>
                                    <input type="number" id="edit-ingredient-calories" step="0.1" min="0" required>
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-alcohol">Alcohol (g):</label>
                                    <input type="number" id="edit-ingredient-alcohol" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-caffeine">Caffeine (mg):</label>
                                    <input type="number" id="edit-ingredient-caffeine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-water">Water (g):</label>
                                    <input type="number" id="edit-ingredient-water" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Carbohydrates Section -->
                        <div class="nutrition-section">
                            <h4>Carbohydrates</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-carbs">Carbs (g):</label>
                                    <input type="number" id="edit-ingredient-carbs" step="0.1" min="0" required>
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-fiber">Fiber (g):</label>
                                    <input type="number" id="edit-ingredient-fiber" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-starch">Starch (g):</label>
                                    <input type="number" id="edit-ingredient-starch" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-sugars">Sugars (g):</label>
                                    <input type="number" id="edit-ingredient-sugars" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-added-sugars">Added Sugars (g):</label>
                                    <input type="number" id="edit-ingredient-added-sugars" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-net-carbs">Net Carbs (g):</label>
                                    <input type="number" id="edit-ingredient-net-carbs" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Lipids Section -->
                        <div class="nutrition-section">
                            <h4>Lipids</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-fats">Fat (g):</label>
                                    <input type="number" id="edit-ingredient-fats" step="0.1" min="0" required>
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-monounsaturated">Monounsaturated (g):</label>
                                    <input type="number" id="edit-ingredient-monounsaturated" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-polyunsaturated">Polyunsaturated (g):</label>
                                    <input type="number" id="edit-ingredient-polyunsaturated" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-omega3">Omega 3 (g):</label>
                                    <input type="number" id="edit-ingredient-omega3" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-omega6">Omega 6 (g):</label>
                                    <input type="number" id="edit-ingredient-omega6" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-saturated">Saturated (g):</label>
                                    <input type="number" id="edit-ingredient-saturated" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-trans-fat">Trans Fat (g):</label>
                                    <input type="number" id="edit-ingredient-trans-fat" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-cholesterol">Cholesterol (mg):</label>
                                    <input type="number" id="edit-ingredient-cholesterol" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Protein Section -->
                        <div class="nutrition-section">
                            <h4>Protein</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-protein">Protein (g):</label>
                                    <input type="number" id="edit-ingredient-protein" step="0.1" min="0" required>
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-cystine">Cystine (g):</label>
                                    <input type="number" id="edit-ingredient-cystine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-histidine">Histidine (g):</label>
                                    <input type="number" id="edit-ingredient-histidine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-isoleucine">Isoleucine (g):</label>
                                    <input type="number" id="edit-ingredient-isoleucine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-leucine">Leucine (g):</label>
                                    <input type="number" id="edit-ingredient-leucine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-lysine">Lysine (g):</label>
                                    <input type="number" id="edit-ingredient-lysine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-methionine">Methionine (g):</label>
                                    <input type="number" id="edit-ingredient-methionine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-phenylalanine">Phenylalanine (g):</label>
                                    <input type="number" id="edit-ingredient-phenylalanine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-threonine">Threonine (g):</label>
                                    <input type="number" id="edit-ingredient-threonine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-tryptophan">Tryptophan (g):</label>
                                    <input type="number" id="edit-ingredient-tryptophan" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-tyrosine">Tyrosine (g):</label>
                                    <input type="number" id="edit-ingredient-tyrosine" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-valine">Valine (g):</label>
                                    <input type="number" id="edit-ingredient-valine" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Vitamins Section -->
                        <div class="nutrition-section">
                            <h4>Vitamins</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-b1">B1 (Thiamine) (mg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-b1" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-b2">B2 (Riboflavin) (mg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-b2" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-b3">B3 (Niacin) (mg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-b3" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-b5">B5 (Pantothenic Acid) (mg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-b5" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-b6">B6 (Pyridoxine) (mg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-b6" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-b12">B12 (Cobalamin) (µg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-b12" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-folate">Folate (µg):</label>
                                    <input type="number" id="edit-ingredient-folate" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-a">Vitamin A (µg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-a" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-c">Vitamin C (mg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-c" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-d">Vitamin D (IU):</label>
                                    <input type="number" id="edit-ingredient-vitamin-d" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-e">Vitamin E (mg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-e" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="edit-ingredient-vitamin-k">Vitamin K (µg):</label>
                                    <input type="number" id="edit-ingredient-vitamin-k" step="0.1" min="0">
                                </div>
                            </div>
                        </div>

                        <!-- Minerals Section -->
                        <div class="nutrition-section">
                            <h4>Minerals</h4>
                            <div class="nutrition-grid">
                                <div class="nutrition-item">
                                    <label for="add-ingredient-calcium">Calcium (mg):</label>
                                    <input type="number" id="add-ingredient-calcium" name="ingredient-calcium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-copper">Copper (mg):</label>
                                    <input type="number" id="add-ingredient-copper" name="ingredient-copper" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-iron">Iron (mg):</label>
                                    <input type="number" id="add-ingredient-iron" name="ingredient-iron" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-magnesium">Magnesium (mg):</label>
                                    <input type="number" id="add-ingredient-magnesium" name="ingredient-magnesium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-manganese">Manganese (mg):</label>
                                    <input type="number" id="add-ingredient-manganese" name="ingredient-manganese" step="0.01" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-phosphorus">Phosphorus (mg):</label>
                                    <input type="number" id="add-ingredient-phosphorus" name="ingredient-phosphorus" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-potassium">Potassium (mg):</label>
                                    <input type="number" id="add-ingredient-potassium" name="ingredient-potassium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-selenium">Selenium (µg):</label>
                                    <input type="number" id="add-ingredient-selenium" name="ingredient-selenium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-sodium">Sodium (mg):</label>
                                    <input type="number" id="add-ingredient-sodium" name="ingredient-sodium" step="0.1" min="0">
                                </div>
                                <div class="nutrition-item">
                                    <label for="add-ingredient-zinc">Zinc (mg):</label>
                                    <input type="number" id="add-ingredient-zinc" name="ingredient-zinc" step="0.01" min="0">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="form-actions">
                        <button type="submit" class="save-ingredient-btn">Add Ingredient</button>
                        <button type="button" class="cancel-add-btn">Cancel</button>
                    </div>
                </form>
                <div class="add-ingredient-status status"></div>
            </div>

            <!-- Edit Ingredient Form -->
            <div class="edit-ingredient-form" style="display: none;">
                <h4>Edit Ingredient</h4>
                <form id="edit-ingredient-form" class="ingredient-item">
                    <input type="hidden" id="edit-ingredient-id" name="ingredient-id">
                    <input type="hidden" id="edit-recipe-id" name="recipe-id">

                    <!-- Form content will be populated dynamically -->

                    <div class="form-actions">
                        <button type="submit" class="save-ingredient-btn">Save Changes</button>
                        <button type="button" class="cancel-edit-btn">Cancel</button>
                    </div>
                </form>
                <div class="edit-ingredient-status status"></div>
            </div>
        `;

        container.innerHTML = tableHtml;

        // Add event listeners for the edit buttons
        const editButtons = container.querySelectorAll('.edit-ingredient-btn');
        editButtons.forEach(button => {
            button.addEventListener('click', handleEditIngredientClick);
        });

        // Add event listener for the detailed nutrition toggle button
        const toggleButton = container.querySelector('.toggle-detailed-nutrition');
        if (toggleButton) {
            toggleButton.addEventListener('click', function() {
                const detailedNutritionContainer = container.querySelector('.detailed-nutrition-container');
                if (detailedNutritionContainer) {
                    // Toggle visibility
                    const isVisible = detailedNutritionContainer.style.display !== 'none';
                    detailedNutritionContainer.style.display = isVisible ? 'none' : 'block';

                    // Update button text
                    this.textContent = isVisible ? 'Show Detailed Nutrition' : 'Hide Detailed Nutrition';
                }
            });
        }

        // Add event listener for the "Add Ingredient" button
        const addIngredientButton = container.querySelector('.add-ingredient-to-recipe-btn');
        if (addIngredientButton) {
            addIngredientButton.addEventListener('click', function() {
                // Get the recipe ID from the first ingredient row
                let recipeId = null;
                const firstRow = container.querySelector('tr[data-recipe-id]');
                if (firstRow) {
                    recipeId = firstRow.dataset.recipeId;
                }

                if (!recipeId) {
                    console.error('Could not determine recipe ID for adding ingredient');
                    return;
                }

                // Show the add ingredient form
                const addForm = container.querySelector('.add-ingredient-form');
                if (addForm) {
                    // Set the recipe ID in the form
                    document.getElementById('add-ingredient-recipe-id').value = recipeId;

                    // Load existing ingredients for the dropdown
                    loadExistingIngredients();

                    // Show the form
                    addForm.style.display = 'block';

                    // Initialize the Cronometer text parser for the form
                    if (typeof initializeCronometerTextParser === 'function') {
                        console.log('Initializing Cronometer text parser for add ingredient form');
                        initializeCronometerTextParser(addForm);
                    } else {
                        console.warn('Cronometer text parser not available');
                    }

                    // Scroll to the form
                    addForm.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        }

        // Add event listener for the add ingredient form
        const addIngredientForm = container.querySelector('#add-ingredient-form');
        if (addIngredientForm) {
            addIngredientForm.addEventListener('submit', handleAddIngredientSubmit);
        }

        // Add event listener for the cancel button in add form
        const cancelAddButton = container.querySelector('.cancel-add-btn');
        if (cancelAddButton) {
            cancelAddButton.addEventListener('click', () => {
                container.querySelector('.add-ingredient-form').style.display = 'none';
            });
        }

        // Add event listener for the ingredient selection type radio buttons
        const ingredientSelectionRadios = container.querySelectorAll('input[name="ingredient-selection-type"]');
        if (ingredientSelectionRadios.length > 0) {
            ingredientSelectionRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    const existingIngredientSection = document.getElementById('existing-ingredient-selection');
                    const nameInput = document.getElementById('add-ingredient-name');

                    // Re-initialize the Cronometer text parser when switching to "Create new ingredient"
                    if (this.value === 'new' && typeof initializeCronometerTextParser === 'function') {
                        console.log('Re-initializing Cronometer text parser after switching to new ingredient');
                        const form = document.getElementById('add-ingredient-form');
                        if (form) {
                            initializeCronometerTextParser(form);
                        }
                    }

                    if (this.value === 'existing') {
                        // Show existing ingredient dropdown, disable name field
                        existingIngredientSection.style.display = 'block';
                        nameInput.disabled = true;
                    } else {
                        // Hide existing ingredient dropdown, enable name field
                        existingIngredientSection.style.display = 'none';
                        nameInput.disabled = false;
                        nameInput.value = '';
                    }
                });
            });
        }

        // Add event listener for the existing ingredient select dropdown
        const existingIngredientSelect = container.querySelector('#existing-ingredient-select');
        if (existingIngredientSelect) {
            existingIngredientSelect.addEventListener('change', function() {
                const selectedOption = this.options[this.selectedIndex];
                const ingredientId = selectedOption.value;

                if (ingredientId) {
                    // Fetch the ingredient details and populate the form
                    fetchIngredientDetails(ingredientId);
                }
            });
        }

        // Add event listener for the edit form
        const editForm = container.querySelector('#edit-ingredient-form');
        if (editForm) {
            editForm.addEventListener('submit', handleEditIngredientSubmit);

            // Initialize the Cronometer text parser for the edit form
            if (typeof initializeCronometerTextParser === 'function') {
                console.log('Initializing Cronometer text parser for edit form');
                initializeCronometerTextParser(editForm);
            }
        }

        // Add event listener for the cancel button in edit form
        const cancelEditButton = container.querySelector('.cancel-edit-btn');
        if (cancelEditButton) {
            cancelEditButton.addEventListener('click', () => {
                container.querySelector('.edit-ingredient-form').style.display = 'none';
            });
        }

        // Initialize the Cronometer text parser for the add form
        const addForm = container.querySelector('#add-ingredient-form');
        if (addForm && typeof initializeCronometerTextParser === 'function') {
            console.log('Initializing Cronometer text parser for add form');
            initializeCronometerTextParser(addForm);
        }
    }

    // Handle edit ingredient button click
    function handleEditIngredientClick(event) {
        const row = event.target.closest('tr');
        const ingredientId = row.dataset.ingredientId;
        const recipeId = row.dataset.recipeId;
        const container = row.closest('.ingredient-details');
        const editForm = container.querySelector('.edit-ingredient-form');
        const statusElement = container.querySelector('.edit-ingredient-status');

        // Show the edit form
        editForm.style.display = 'block';

        // Initialize the Cronometer text parser for the form
        if (typeof initializeCronometerTextParser === 'function') {
            console.log('Initializing Cronometer text parser for edit ingredient form');
            initializeCronometerTextParser(editForm);
        } else {
            console.warn('Cronometer text parser not available');
        }

        // IMPORTANT: Check if we have a UI-updated value for this ingredient
        // This ensures the edit form shows the most recent value even if the database hasn't been updated
        const packageAmountElement = row.querySelector(`.ingredient-package-amount[data-ingredient-id="${ingredientId}"]`);
        let uiPackageAmount = null;
        if (packageAmountElement) {
            uiPackageAmount = packageAmountElement.getAttribute('data-value');
            console.debug(`Found UI-updated package amount: ${uiPackageAmount}`);
        }

        // Fetch the full ingredient data from the API
        fetch(`/api/recipes/${recipeId}/ingredients/${ingredientId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(ingredient => {
                // Log the ingredient data to see what's being returned
                console.debug('Ingredient data from API:', ingredient);

                // If we have a UI-updated value, override the database value
                if (uiPackageAmount !== null) {
                    console.debug(`Overriding database package amount (${ingredient.package_amount}) with UI value (${uiPackageAmount})`);
                    ingredient.package_amount = parseFloat(uiPackageAmount);
                }

                // Populate form fields with current values
                document.getElementById('edit-ingredient-id').value = ingredientId;
                document.getElementById('edit-recipe-id').value = recipeId;

                // Basic information
                document.getElementById('edit-ingredient-name').value = ingredient.name || '';
                document.getElementById('edit-ingredient-amount').value = ingredient.amount || '';
                // Handle package_amount specially
                console.debug('Package amount from API:', ingredient.package_amount, typeof ingredient.package_amount);

                // First check if we have a value in local storage
                let packageAmountForForm = '';

                if (window.localStorageManager) {
                    const savedPackageAmount = window.localStorageManager.getPackageAmount(ingredientId);
                    if (savedPackageAmount !== null) {
                        console.debug(`Found saved package amount in local storage for ingredient ${ingredientId}: ${savedPackageAmount}`);
                        packageAmountForForm = savedPackageAmount;
                    } else if (ingredient.package_amount !== null && ingredient.package_amount !== undefined) {
                        // Always convert to number
                        packageAmountForForm = Number(ingredient.package_amount);

                        // If conversion failed, set to empty string
                        if (isNaN(packageAmountForForm)) {
                            packageAmountForForm = '';
                        }
                    }
                } else if (ingredient.package_amount !== null && ingredient.package_amount !== undefined) {
                    // Always convert to number
                    packageAmountForForm = Number(ingredient.package_amount);

                    // If conversion failed, set to empty string
                    if (isNaN(packageAmountForForm)) {
                        packageAmountForForm = '';
                    }
                }

                document.getElementById('edit-ingredient-package-amount').value = packageAmountForForm;
                console.debug('Package amount set in form:', packageAmountForForm);

                // Store the current package amount in a global variable for reference
                window._currentPackageAmount = packageAmountForForm;
                document.getElementById('edit-ingredient-price').value = ingredient.price || '';

                // General section
                document.getElementById('edit-ingredient-calories').value = ingredient.calories || '';
                document.getElementById('edit-ingredient-alcohol').value = ingredient.alcohol || '';
                document.getElementById('edit-ingredient-caffeine').value = ingredient.caffeine || '';
                document.getElementById('edit-ingredient-water').value = ingredient.water || '';

                // Carbohydrates section
                document.getElementById('edit-ingredient-carbs').value = ingredient.carbohydrates || '';
                document.getElementById('edit-ingredient-fiber').value = ingredient.fiber || '';
                document.getElementById('edit-ingredient-starch').value = ingredient.starch || '';
                document.getElementById('edit-ingredient-sugars').value = ingredient.sugars || '';
                document.getElementById('edit-ingredient-added-sugars').value = ingredient.added_sugars || '';
                document.getElementById('edit-ingredient-net-carbs').value = ingredient.net_carbs || '';

                // Lipids section
                document.getElementById('edit-ingredient-fats').value = ingredient.fats || '';
                document.getElementById('edit-ingredient-monounsaturated').value = ingredient.monounsaturated || '';
                document.getElementById('edit-ingredient-polyunsaturated').value = ingredient.polyunsaturated || '';

                // CRITICAL FIX: Handle both omega3/omega6 and omega_3/omega_6 naming conventions
                const omega3Value = ingredient.omega3 !== undefined ? ingredient.omega3 :
                                   (ingredient.omega_3 !== undefined ? ingredient.omega_3 : '');
                document.getElementById('edit-ingredient-omega3').value = omega3Value;
                console.log(`Setting omega3 input value to ${omega3Value} (from database: omega3=${ingredient.omega3}, omega_3=${ingredient.omega_3})`);

                const omega6Value = ingredient.omega6 !== undefined ? ingredient.omega6 :
                                   (ingredient.omega_6 !== undefined ? ingredient.omega_6 : '');
                document.getElementById('edit-ingredient-omega6').value = omega6Value;
                console.log(`Setting omega6 input value to ${omega6Value} (from database: omega6=${ingredient.omega6}, omega_6=${ingredient.omega_6})`);

                document.getElementById('edit-ingredient-saturated').value = ingredient.saturated || '';
                document.getElementById('edit-ingredient-trans-fat').value = ingredient.trans_fat || '';
                console.log('Setting trans_fat value in form:', ingredient.trans_fat);
                document.getElementById('edit-ingredient-cholesterol').value = ingredient.cholesterol || '';

                // Protein section
                document.getElementById('edit-ingredient-protein').value = ingredient.protein || '';
                document.getElementById('edit-ingredient-cystine').value = ingredient.cystine || '';
                document.getElementById('edit-ingredient-histidine').value = ingredient.histidine || '';
                document.getElementById('edit-ingredient-isoleucine').value = ingredient.isoleucine || '';
                document.getElementById('edit-ingredient-leucine').value = ingredient.leucine || '';
                document.getElementById('edit-ingredient-lysine').value = ingredient.lysine || '';
                document.getElementById('edit-ingredient-methionine').value = ingredient.methionine || '';
                document.getElementById('edit-ingredient-phenylalanine').value = ingredient.phenylalanine || '';
                document.getElementById('edit-ingredient-threonine').value = ingredient.threonine || '';
                document.getElementById('edit-ingredient-tryptophan').value = ingredient.tryptophan || '';
                document.getElementById('edit-ingredient-tyrosine').value = ingredient.tyrosine || '';
                document.getElementById('edit-ingredient-valine').value = ingredient.valine || '';

                // Vitamins section
                document.getElementById('edit-ingredient-vitamin-b1').value = ingredient.thiamine || '';
                document.getElementById('edit-ingredient-vitamin-b2').value = ingredient.riboflavin || '';
                document.getElementById('edit-ingredient-vitamin-b3').value = ingredient.niacin || '';
                document.getElementById('edit-ingredient-vitamin-b5').value = ingredient.pantothenic_acid || '';
                document.getElementById('edit-ingredient-vitamin-b6').value = ingredient.vitamin_b6 || '';
                document.getElementById('edit-ingredient-vitamin-b12').value = ingredient.vitamin_b12 || '';
                document.getElementById('edit-ingredient-folate').value = ingredient.folate || '';
                document.getElementById('edit-ingredient-vitamin-a').value = ingredient.vitamin_a || '';
                document.getElementById('edit-ingredient-vitamin-c').value = ingredient.vitamin_c || '';
                document.getElementById('edit-ingredient-vitamin-d').value = ingredient.vitamin_d || '';
                document.getElementById('edit-ingredient-vitamin-e').value = ingredient.vitamin_e || '';
                document.getElementById('edit-ingredient-vitamin-k').value = ingredient.vitamin_k || '';

                // Minerals section
                document.getElementById('edit-ingredient-calcium').value = ingredient.calcium || '';
                document.getElementById('edit-ingredient-copper').value = ingredient.copper || '';
                document.getElementById('edit-ingredient-iron').value = ingredient.iron || '';
                document.getElementById('edit-ingredient-magnesium').value = ingredient.magnesium || '';
                document.getElementById('edit-ingredient-manganese').value = ingredient.manganese || '';
                document.getElementById('edit-ingredient-phosphorus').value = ingredient.phosphorus || '';
                document.getElementById('edit-ingredient-potassium').value = ingredient.potassium || '';
                document.getElementById('edit-ingredient-selenium').value = ingredient.selenium || '';
                document.getElementById('edit-ingredient-sodium').value = ingredient.sodium || '';
                document.getElementById('edit-ingredient-zinc').value = ingredient.zinc || '';

                // Clear any previous status messages
                showStatus(statusElement, '', '');

                // Scroll to the edit form
                editForm.scrollIntoView({ behavior: 'smooth' });
            })
            .catch(error => {
                console.error('Error fetching ingredient details:', error);

                // Fallback to basic data from the table if API fails
                const cells = row.querySelectorAll('td');
                document.getElementById('edit-ingredient-id').value = ingredientId;
                document.getElementById('edit-recipe-id').value = recipeId;
                document.getElementById('edit-ingredient-name').value = cells[0].textContent;
                document.getElementById('edit-ingredient-calories').value = parseFloat(cells[1].textContent);
                document.getElementById('edit-ingredient-amount').value = parseFloat(cells[2].textContent);
                document.getElementById('edit-ingredient-protein').value = parseFloat(cells[3].textContent);
                document.getElementById('edit-ingredient-fats').value = parseFloat(cells[4].textContent);
                document.getElementById('edit-ingredient-carbs').value = parseFloat(cells[5].textContent);
                document.getElementById('edit-ingredient-price').value = parseFloat(cells[6].textContent);

                showStatus(statusElement, 'Could not fetch detailed ingredient data. Basic data loaded.', 'warning');

                // Scroll to the edit form
                editForm.scrollIntoView({ behavior: 'smooth' });
            });
    }

    // Helper function to parse float values safely
    function parseFloatOrNull(value) {
        if (value === undefined || value === null || value === '') {
            return null;
        }
        const parsed = parseFloat(value);
        return isNaN(parsed) ? null : parsed;
    }

    // Handle edit ingredient form submission
    async function handleEditIngredientSubmit(event) {
        event.preventDefault();

        console.log('=== handleEditIngredientSubmit called ===');

        // Check if the field updater is available
        if (!window.fieldUpdater) {
            console.warn('Field updater not available. Some fields may not be saved correctly.');
        }

        const form = event.target;
        const container = form.closest('.ingredient-details');
        const statusElement = container.querySelector('.edit-ingredient-status');

        // Get the recipe card that contains this ingredient
        const recipeCard = container.closest('.recipe-card');

        // Show loading status
        showStatus(statusElement, 'Saving changes...', 'info');

        // Get basic form values
        const ingredientId = document.getElementById('edit-ingredient-id').value;
        const recipeId = document.getElementById('edit-recipe-id').value;
        const name = document.getElementById('edit-ingredient-name').value.trim();
        const amount = parseFloat(document.getElementById('edit-ingredient-amount').value);
        // Get package amount from the input field
        const packageAmountInput = document.getElementById('edit-ingredient-package-amount').value;
        console.log('Raw package amount input:', packageAmountInput);

        // Create the ingredient data object first
        const ingredientData = {
            name: document.getElementById('edit-ingredient-name').value.trim(),
            calories: parseFloat(document.getElementById('edit-ingredient-calories').value),
            amount: parseFloat(document.getElementById('edit-ingredient-amount').value)
        };

        // Get all input fields with IDs starting with 'edit-ingredient-'
        const allInputs = document.querySelectorAll('input[id^="edit-ingredient-"]');
        allInputs.forEach(input => {
            // Skip the fields we've already processed
            if (input.id === 'edit-ingredient-name' ||
                input.id === 'edit-ingredient-calories' ||
                input.id === 'edit-ingredient-amount' ||
                input.id === 'edit-ingredient-id' ||
                input.id === 'edit-recipe-id') {
                return;
            }

            // Get the field name by removing the 'edit-ingredient-' prefix
            let fieldName = input.id.replace('edit-ingredient-', '');

            // Convert hyphenated names to database column names
            if (fieldName === 'vitamin-a') fieldName = 'vitamin_a';
            else if (fieldName === 'vitamin-b1') fieldName = 'thiamine';
            else if (fieldName === 'vitamin-b2') fieldName = 'riboflavin';
            else if (fieldName === 'vitamin-b3') fieldName = 'niacin';
            else if (fieldName === 'vitamin-b5') fieldName = 'pantothenic_acid';
            else if (fieldName === 'vitamin-b6') fieldName = 'vitamin_b6';
            else if (fieldName === 'vitamin-b12') fieldName = 'vitamin_b12';
            else if (fieldName === 'vitamin-c') fieldName = 'vitamin_c';
            else if (fieldName === 'vitamin-d') fieldName = 'vitamin_d';
            else if (fieldName === 'vitamin-e') fieldName = 'vitamin_e';
            else if (fieldName === 'vitamin-k') fieldName = 'vitamin_k';
            else if (fieldName === 'trans-fat') fieldName = 'trans';
            else if (fieldName === 'added-sugars') fieldName = 'added_sugars';
            else if (fieldName === 'net-carbs') fieldName = 'net_carbs';
            else if (fieldName === 'omega3') fieldName = 'omega3';
            else if (fieldName === 'omega6') fieldName = 'omega6';
            else fieldName = fieldName.replace(/-/g, '_');

            // Get the value and convert to number if possible
            let value = input.value.trim();
            if (value !== '') {
                value = parseFloat(value);
                if (!isNaN(value)) {
                    ingredientData[fieldName] = value;
                }
            }
        });

        // Store the package amount for later use
        // Make sure we properly handle the package amount value
        let packageAmount = null;
        if (packageAmountInput && packageAmountInput.trim() !== '') {
            packageAmount = Number(packageAmountInput);
            // If conversion to number failed, set to null
            if (isNaN(packageAmount)) {
                packageAmount = null;
                console.warn('Package amount input could not be converted to a number:', packageAmountInput);
            }
        }
        console.log('Package amount to send:', packageAmount, typeof packageAmount);

        // Log the package amount for debugging
        console.log('Package amount value:', packageAmount, typeof packageAmount);

        // CRITICAL FIX: Store the package amount in a global variable for direct update
        window._lastPackageAmount = packageAmount;

        // Check if the package amount has actually changed
        const hasPackageAmountChanged = window._currentPackageAmount !== packageAmount;
        console.debug(`Package amount changed: ${hasPackageAmountChanged} (from ${window._currentPackageAmount} to ${packageAmount})`);
        window._packageAmountChanged = hasPackageAmountChanged;

        // Initialize omega_3 and omega_6 tracking variables
        window._lastOmega3Value = undefined;
        window._omega3Changed = false;
        window._lastOmega6Value = undefined;
        window._omega6Changed = false;

        // Also add it to the form data explicitly
        ingredientData.package_amount = packageAmount;

        console.log('Package amount input:', packageAmountInput, 'Parsed value:', packageAmount, 'Type:', typeof packageAmount);
        const price = parseFloat(document.getElementById('edit-ingredient-price').value);

        // Make sure the required fields are included
        ingredientData.protein = parseFloat(document.getElementById('edit-ingredient-protein').value);
        ingredientData.fats = parseFloat(document.getElementById('edit-ingredient-fats').value);
        ingredientData.carbohydrates = parseFloat(document.getElementById('edit-ingredient-carbs').value);
        ingredientData.price = price;

        // Get values for validation
        const ingredientName = ingredientData.name;
        const caloriesValue = ingredientData.calories;
        const amountValue = ingredientData.amount;
        const proteinValue = ingredientData.protein;
        const fatsValue = ingredientData.fats;
        const carbsValue = ingredientData.carbohydrates;

        // Validate required form values
        if (!ingredientName || isNaN(caloriesValue) || isNaN(amountValue) || isNaN(proteinValue) || isNaN(fatsValue) || isNaN(carbsValue) || isNaN(price)) {
            showStatus(statusElement, 'Please fill all required fields with valid values.', 'error');
            return;
        }

        // Log the data for debugging
        console.log('Data being sent to API:', ingredientData);

        // Log the data being sent to the API
        console.log('Sending ingredient data to API:', JSON.stringify(ingredientData, null, 2));
        console.log('Package amount value:', packageAmount, typeof packageAmount);

        // All optional fields are now handled by the dynamic field collection above

        // Store special values for later use
        const omega3 = parseFloat(document.getElementById('edit-ingredient-omega3').value);
        if (!isNaN(omega3)) {
            // Store the omega3 value for later use
            window._lastOmega3Value = omega3;
            window._omega3Changed = true;
        }

        const omega6 = parseFloat(document.getElementById('edit-ingredient-omega6').value);
        if (!isNaN(omega6)) {
            // Store the omega6 value for later use
            window._lastOmega6Value = omega6;
            window._omega6Changed = true;
        }

        const transFat = parseFloat(document.getElementById('edit-ingredient-trans-fat').value);
        if (!isNaN(transFat)) {
            // Also save the trans fat value for direct update
            window._lastTransFatValue = transFat;
            window._transFatChanged = true;

            // Immediately send a direct update request for the trans fat value
            try {
                console.log('Sending direct trans fat update request...');
                const directUpdateResponse = await fetch('/api/direct/update-trans-fat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        ingredientId: ingredientId,
                        transFatValue: transFat
                    })
                });

                if (directUpdateResponse.ok) {
                    const result = await directUpdateResponse.json();
                    console.log('Direct trans fat update successful:', result);
                } else {
                    console.error('Direct trans fat update failed:', await directUpdateResponse.text());
                }
            } catch (error) {
                console.error('Error sending direct trans fat update:', error);
            }
        }

        // All optional fields are now handled by the dynamic field collection above

        try {
            // Store the trans fat value for later use in the main update
            if (window._lastTransFatValue !== undefined && window._transFatChanged) {
                console.debug('Storing trans fat value for main update:', window._lastTransFatValue);
                // We'll include this in the main PATCH request below
            }

            // CRITICAL FIX: Next, update the package amount using our direct endpoint
            // Only do this if the package amount has actually changed
            if (window._lastPackageAmount !== undefined && window._packageAmountChanged) {
                console.debug('Updating package amount using direct endpoint:', window._lastPackageAmount);
                try {
                    // Use the standard ingredient update endpoint instead
                    // The specialized package-amount endpoint doesn't exist
                    // Use safeFetch if available, otherwise fall back to regular fetch
                    const fetchFunction = window.safeFetch || fetch;
                    const packageResponse = await fetchFunction(`/api/recipes/${recipeId}/ingredients/${ingredientId}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            // Only send the package_amount to avoid changing other fields
                            package_amount: window._lastPackageAmount
                        })
                    });

                    if (!packageResponse.ok) {
                        // Silently handle the error - we'll force the UI update anyway
                        console.debug('Server error updating package amount - will force UI update');
                    } else {
                        console.log('Package amount updated successfully using direct endpoint');

                        // Get the response from the direct update endpoint
                        const updateResult = await packageResponse.json();
                        console.log('=== Response from direct package amount update ===');
                        console.log('Update result:', updateResult);

                        // The direct update endpoint returns before/after data
                        if (updateResult.before && updateResult.after) {
                            console.log('Before package_amount:', updateResult.before.package_amount);
                            console.log('After package_amount:', updateResult.after.package_amount);
                        }

                        // We need to fetch the full recipe to get all ingredients
                        // Add a small delay to ensure the database has time to update
                        await new Promise(resolve => setTimeout(resolve, 100));

                        const recipeResponse = await fetch(`/api/recipes/${recipeId}?nocache=${new Date().getTime()}`);
                        if (!recipeResponse.ok) {
                            throw new Error(`Failed to fetch updated recipe: ${recipeResponse.status}`);
                        }

                        // Get the updated recipe
                        const updatedRecipe = await recipeResponse.json();
                        console.log('Updated recipe:', updatedRecipe);

                        // Find the updated ingredient
                        const updatedIngredient = updatedRecipe.ingredients.find(ing => ing.id == ingredientId);
                        if (updatedIngredient) {
                            console.log('Updated ingredient:', updatedIngredient);
                            console.log('Updated package_amount:', updatedIngredient.package_amount);
                        }

                        // CRITICAL FIX: Force a complete refresh of the recipe data from the server
                        // This is the most reliable way to ensure the UI shows the latest data
                        try {
                            console.log('Forcing a complete refresh of recipe data from server');

                            // Make a fresh request to get the latest recipe data with the updated package amount
                            const freshResponse = await fetch(`/api/recipes/${recipeId}?nocache=${new Date().getTime()}`);
                            if (!freshResponse.ok) {
                                throw new Error(`HTTP error! status: ${freshResponse.status}`);
                            }

                            // Get the latest recipe data
                            const freshRecipeData = await freshResponse.json();
                            console.log('Fresh recipe data from server:', freshRecipeData);

                            // Log the updated package amounts for debugging
                            freshRecipeData.ingredients.forEach(ing => {
                                console.log(`Fresh data - Ingredient ${ing.name} package_amount:`, ing.package_amount, typeof ing.package_amount);
                            });

                            // Find the ingredient that was just updated
                            const updatedIngredient = freshRecipeData.ingredients.find(ing => ing.id == ingredientId);
                            if (updatedIngredient) {
                                console.log('Updated ingredient from fresh data:', updatedIngredient);
                                console.log('Updated package_amount from fresh data:', updatedIngredient.package_amount);
                            }

                            if (recipeCard) {
                                const detailsDiv = recipeCard.querySelector('.ingredient-details');
                                const viewButton = recipeCard.querySelector('.view-ingredients-btn');

                                // Force a complete refresh of the ingredient details
                                if (detailsDiv) {
                                    // Clear and show the details div
                                    detailsDiv.innerHTML = '<p>Refreshing data...</p>';
                                    detailsDiv.style.display = 'block';

                                    // Update the button state
                                    if (viewButton) {
                                        viewButton.textContent = 'Hide';
                                        viewButton.classList.add('active');
                                    }

                                    // Render the fresh data
                                    renderIngredientDetails(freshRecipeData.ingredients, detailsDiv);
                                }
                            } else {
                                // Fallback to just updating the displayed ingredients
                                renderIngredientDetails(freshRecipeData.ingredients, container);
                            }
                        } catch (refreshError) {
                            console.error('Error during forced refresh:', refreshError);
                            // Fall back to using the data we already have
                            renderIngredientDetails(updatedRecipe.ingredients, container);
                        }

                        // Hide the edit form if it exists
                        const editForm = container.querySelector('.edit-ingredient-form');
                        if (editForm) {
                            editForm.style.display = 'none';
                        }

                        // Show success message
                        showStatus(statusElement, 'Ingredient updated successfully!', 'success');

                        // Clear the global variables
                        window._lastPackageAmount = undefined;
                        window._lastTransFatValue = undefined;
                        window._transFatChanged = false;
                        window._lastOmega3Value = undefined;
                        window._omega3Changed = false;
                        window._lastOmega6Value = undefined;
                        window._omega6Changed = false;

                        // Return early - we've already updated everything
                        return;
                    }
                } catch (packageError) {
                    console.error('Error updating package amount:', packageError);
                }
            }

            // If we get here, the direct update failed or wasn't attempted
            // Fall back to the original update method

            // Log the data being sent to the server
            console.log('Sending ingredient data to server:', ingredientData);

            // First, update the package amount directly
            // Only do this if the package amount has actually changed
            if (window._lastPackageAmount !== undefined && window._packageAmountChanged) {
                console.debug('Updating package amount directly before main update:', window._lastPackageAmount);

                // Save to local storage as a fallback
                if (window.localStorageManager) {
                    window.localStorageManager.savePackageAmount(ingredientId, window._lastPackageAmount);
                }

                try {
                    // Try to use the dedicated package amount endpoint first
                    const fetchFunction = window.safeFetch || fetch;
                    const packageResponse = await fetchFunction(`/api/package-amount/update`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            ingredientId: ingredientId,
                            packageAmount: window._lastPackageAmount
                        })
                    });

                    if (packageResponse.ok) {
                        console.debug('Package amount updated successfully before main update');
                        const updateResult = await packageResponse.json();

                        // Verify the package amount was updated correctly
                        if (updateResult && updateResult.package_amount) {
                            console.debug('Server confirmed package amount updated to:', updateResult.package_amount);

                            // Force the package amount in the ingredient data to match what was just updated
                            ingredientData.package_amount = updateResult.package_amount;
                        }
                    } else {
                        // Silently handle the error - we'll force the UI update anyway
                        console.debug('Server error updating package amount - will force UI update');
                    }
                } catch (packageError) {
                    console.error('Error updating package amount before main update:', packageError);
                }
            }

            // Use the field updater to update all fields directly
            if (window.fieldUpdater) {
                console.log('Using field updater to update all fields directly');

                // Collect all form values
                const formData = {};

                // Basic fields
                formData['edit-ingredient-name'] = document.getElementById('edit-ingredient-name').value;
                formData['edit-ingredient-calories'] = document.getElementById('edit-ingredient-calories').value;
                formData['edit-ingredient-amount'] = document.getElementById('edit-ingredient-amount').value;
                formData['edit-ingredient-protein'] = document.getElementById('edit-ingredient-protein').value;
                formData['edit-ingredient-fats'] = document.getElementById('edit-ingredient-fats').value;
                formData['edit-ingredient-carbs'] = document.getElementById('edit-ingredient-carbs').value;
                formData['edit-ingredient-price'] = document.getElementById('edit-ingredient-price').value;
                formData['edit-ingredient-package-amount'] = document.getElementById('edit-ingredient-package-amount').value;

                // General section
                formData['edit-ingredient-alcohol'] = document.getElementById('edit-ingredient-alcohol').value;
                formData['edit-ingredient-caffeine'] = document.getElementById('edit-ingredient-caffeine').value;
                formData['edit-ingredient-water'] = document.getElementById('edit-ingredient-water').value;

                // Carbohydrates section
                formData['edit-ingredient-fiber'] = document.getElementById('edit-ingredient-fiber').value;
                formData['edit-ingredient-starch'] = document.getElementById('edit-ingredient-starch').value;
                formData['edit-ingredient-sugars'] = document.getElementById('edit-ingredient-sugars').value;
                formData['edit-ingredient-added-sugars'] = document.getElementById('edit-ingredient-added-sugars').value;
                formData['edit-ingredient-net-carbs'] = document.getElementById('edit-ingredient-net-carbs').value;

                // Lipids section
                formData['edit-ingredient-saturated'] = document.getElementById('edit-ingredient-saturated').value;
                formData['edit-ingredient-monounsaturated'] = document.getElementById('edit-ingredient-monounsaturated').value;
                formData['edit-ingredient-polyunsaturated'] = document.getElementById('edit-ingredient-polyunsaturated').value;
                formData['edit-ingredient-omega3'] = document.getElementById('edit-ingredient-omega3').value;
                formData['edit-ingredient-omega6'] = document.getElementById('edit-ingredient-omega6').value;
                formData['edit-ingredient-trans-fat'] = document.getElementById('edit-ingredient-trans-fat').value;
                formData['edit-ingredient-cholesterol'] = document.getElementById('edit-ingredient-cholesterol').value;

                // Protein section
                formData['edit-ingredient-cystine'] = document.getElementById('edit-ingredient-cystine').value;
                formData['edit-ingredient-histidine'] = document.getElementById('edit-ingredient-histidine').value;
                formData['edit-ingredient-isoleucine'] = document.getElementById('edit-ingredient-isoleucine').value;
                formData['edit-ingredient-leucine'] = document.getElementById('edit-ingredient-leucine').value;
                formData['edit-ingredient-lysine'] = document.getElementById('edit-ingredient-lysine').value;
                formData['edit-ingredient-methionine'] = document.getElementById('edit-ingredient-methionine').value;
                formData['edit-ingredient-phenylalanine'] = document.getElementById('edit-ingredient-phenylalanine').value;
                formData['edit-ingredient-threonine'] = document.getElementById('edit-ingredient-threonine').value;
                formData['edit-ingredient-tryptophan'] = document.getElementById('edit-ingredient-tryptophan').value;
                formData['edit-ingredient-tyrosine'] = document.getElementById('edit-ingredient-tyrosine').value;
                formData['edit-ingredient-valine'] = document.getElementById('edit-ingredient-valine').value;

                // Vitamins section
                formData['edit-ingredient-vitamin-b1'] = document.getElementById('edit-ingredient-vitamin-b1').value;
                formData['edit-ingredient-vitamin-b2'] = document.getElementById('edit-ingredient-vitamin-b2').value;
                formData['edit-ingredient-vitamin-b3'] = document.getElementById('edit-ingredient-vitamin-b3').value;
                formData['edit-ingredient-vitamin-b5'] = document.getElementById('edit-ingredient-vitamin-b5').value;
                formData['edit-ingredient-vitamin-b6'] = document.getElementById('edit-ingredient-vitamin-b6').value;
                formData['edit-ingredient-vitamin-b12'] = document.getElementById('edit-ingredient-vitamin-b12').value;
                formData['edit-ingredient-folate'] = document.getElementById('edit-ingredient-folate').value;
                formData['edit-ingredient-vitamin-a'] = document.getElementById('edit-ingredient-vitamin-a').value;
                formData['edit-ingredient-vitamin-c'] = document.getElementById('edit-ingredient-vitamin-c').value;
                formData['edit-ingredient-vitamin-d'] = document.getElementById('edit-ingredient-vitamin-d').value;
                formData['edit-ingredient-vitamin-e'] = document.getElementById('edit-ingredient-vitamin-e').value;
                formData['edit-ingredient-vitamin-k'] = document.getElementById('edit-ingredient-vitamin-k').value;

                // Minerals section
                formData['edit-ingredient-calcium'] = document.getElementById('edit-ingredient-calcium').value;
                formData['edit-ingredient-copper'] = document.getElementById('edit-ingredient-copper').value;
                formData['edit-ingredient-iron'] = document.getElementById('edit-ingredient-iron').value;
                formData['edit-ingredient-magnesium'] = document.getElementById('edit-ingredient-magnesium').value;
                formData['edit-ingredient-manganese'] = document.getElementById('edit-ingredient-manganese').value;
                formData['edit-ingredient-phosphorus'] = document.getElementById('edit-ingredient-phosphorus').value;
                formData['edit-ingredient-potassium'] = document.getElementById('edit-ingredient-potassium').value;
                formData['edit-ingredient-selenium'] = document.getElementById('edit-ingredient-selenium').value;
                formData['edit-ingredient-sodium'] = document.getElementById('edit-ingredient-sodium').value;
                formData['edit-ingredient-zinc'] = document.getElementById('edit-ingredient-zinc').value;

                // Update all fields directly
                console.log('Updating all fields for ingredient', ingredientId);
                const updateResults = await window.fieldUpdater.updateAllFields(recipeId, ingredientId, formData);
                console.log('Field update results:', updateResults);
            }

            // Add the trans fat value to the ingredient data if it exists
            if (window._lastTransFatValue !== undefined && window._transFatChanged) {
                console.debug('Adding trans_fat to main update request:', window._lastTransFatValue);
                ingredientData.trans_fat = window._lastTransFatValue;
            }

            // Add the omega3 value to the ingredient data if it exists
            if (window._lastOmega3Value !== undefined && window._omega3Changed) {
                // CRITICAL FIX: Use omega3 (without underscore) to match database column name
                console.debug('Adding omega3 to main update request:', window._lastOmega3Value);
                ingredientData.omega3 = window._lastOmega3Value;
            }

            // Add the omega6 value to the ingredient data if it exists
            if (window._lastOmega6Value !== undefined && window._omega6Changed) {
                // CRITICAL FIX: Use omega6 (without underscore) to match database column name
                console.debug('Adding omega6 to main update request:', window._lastOmega6Value);
                ingredientData.omega6 = window._lastOmega6Value;
            }

            // CRITICAL FIX: Save omega values to OmegaStorage
            if ((window._lastOmega3Value !== undefined && window._omega3Changed) ||
                (window._lastOmega6Value !== undefined && window._omega6Changed)) {
                try {
                    if (window.OmegaStorage) {
                        console.log('Saving omega values to OmegaStorage...');
                        const omega3Value = window._lastOmega3Value;
                        const omega6Value = window._lastOmega6Value;

                        // Save omega values to OmegaStorage
                        const saveResult = window.OmegaStorage.saveOmegaValues(
                            ingredientId,
                            omega3Value,
                            omega6Value
                        );

                        if (saveResult) {
                            console.log('Omega values saved successfully to OmegaStorage');

                            // Also update the ingredient data for immediate UI update
                            // CRITICAL FIX: Use omega3 and omega6 (without underscores) to match database column names
                            if (omega3Value !== undefined) {
                                ingredientData.omega3 = omega3Value;
                            }

                            if (omega6Value !== undefined) {
                                ingredientData.omega6 = omega6Value;
                            }
                        } else {
                            console.error('Failed to save omega values to OmegaStorage');
                        }
                    } else {
                        console.warn('OmegaStorage not available');
                    }
                } catch (error) {
                    console.error('Error saving omega values to OmegaStorage:', error);
                }
            }

            // CRITICAL FIX: Log the final data being sent to ensure omega values are included
            console.log('Final ingredient data being sent to API:', ingredientData);
            // CRITICAL FIX: Use omega3 and omega6 (without underscores) to match database column names
            console.log('Omega3 value in request:', ingredientData.omega3);
            console.log('Omega6 value in request:', ingredientData.omega6);

            // Call the API to update the ingredient
            const response = await fetch(`/api/recipes/${recipeId}/ingredients/${ingredientId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(ingredientData)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }

            const updatedRecipe = await response.json();

            console.debug('=== Response from server ===');
            console.debug('Updated recipe received');

            // Find the updated ingredient
            const updatedIngredient = updatedRecipe.ingredients.find(ing => ing.id == ingredientId);
            if (updatedIngredient) {
                console.debug('Updated ingredient:', updatedIngredient.name);
                console.debug('Updated package_amount:', updatedIngredient.package_amount);

                // If the package amount doesn't match what we sent, log a warning
                // Only do this if the package amount has actually changed
                if (updatedIngredient.package_amount !== window._lastPackageAmount && window._packageAmountChanged) {
                    console.debug('Package amount mismatch! Sent:', window._lastPackageAmount, 'Received:', updatedIngredient.package_amount);

                    // Save to local storage as a fallback
                    if (window.localStorageManager) {
                        window.localStorageManager.savePackageAmount(ingredientId, window._lastPackageAmount);
                    }

                    // Try one more direct update to ensure the package amount is correct
                    try {
                        console.debug('Attempting final package amount correction...');
                        // Try to use the dedicated package amount endpoint first
                        const fetchFunction = window.safeFetch || fetch;
                        const finalUpdateResponse = await fetchFunction(`/api/package-amount/update`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                ingredientId: ingredientId,
                                packageAmount: window._lastPackageAmount
                            })
                        });

                        if (finalUpdateResponse.ok) {
                            console.debug('Final package amount correction successful');
                        }
                    } catch (finalUpdateError) {
                        // Silently handle the error - we'll force the UI update anyway
                        console.debug('Error during final package amount correction - will force UI update');
                    }
                }
            }

            // CRITICAL FIX: Force a complete refresh of the recipe data from the server
            // This is the most reliable way to ensure the UI shows the latest data
            try {
                console.debug('Forcing a complete refresh of recipe data from server');

                // Add a longer delay to ensure the database has time to update
                await new Promise(resolve => setTimeout(resolve, 500));

                // Make one final direct update to ensure the package amount is correct
                // Only do this if the package amount has actually changed
                try {
                    let freshRecipeData;
                    if (window._packageAmountChanged) {
                        console.debug('Making final direct package amount update...');

                        // Save to local storage as a fallback
                        if (window.localStorageManager) {
                            window.localStorageManager.savePackageAmount(ingredientId, window._lastPackageAmount);
                        }

                        try {
                            // Try to use the dedicated package amount endpoint first
                            const fetchFunction = window.safeFetch || fetch;
                            const finalUpdateResponse = await fetchFunction(`/api/package-amount/update`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    ingredientId: ingredientId,
                                    packageAmount: window._lastPackageAmount
                                })
                            });

                            if (finalUpdateResponse.ok) {
                                console.debug('Final direct package amount update successful');
                                // Use this response as our fresh data
                                freshRecipeData = await finalUpdateResponse.json();
                                console.debug('Fresh recipe data from direct update received');
                            } else {
                                // Silently handle the error - we'll force the UI update anyway
                                console.debug('Server error in final direct update - will force UI update');
                            }
                        } catch (error) {
                            // Silently handle the error - we'll force the UI update anyway
                            console.debug('Error in final direct update - will force UI update');
                        }
                    }

                    // Check if we have fresh recipe data
                    if (freshRecipeData && freshRecipeData.ingredients) {
                        // Log the updated package amounts for debugging
                        freshRecipeData.ingredients.forEach(ing => {
                            console.debug(`Fresh data - Ingredient ${ing.name} package_amount:`, ing.package_amount);
                        });

                        // Find the ingredient that was just updated
                        const updatedIngredient = freshRecipeData.ingredients.find(ing => ing.id == ingredientId);
                        if (updatedIngredient) {
                            console.debug('Updated ingredient from fresh data:', updatedIngredient.name);
                            console.debug('Updated package_amount from fresh data:', updatedIngredient.package_amount);

                            // CRITICAL FIX: Force the package amount to match what we sent
                            // This ensures the UI shows the correct value even if the server didn't update it
                            if (window._lastPackageAmount !== undefined) {
                                console.debug('Forcing package amount in the UI to match what was entered:', window._lastPackageAmount);
                                updatedIngredient.package_amount = window._lastPackageAmount;

                                // Also update the DOM directly for any existing elements
                                const packageAmountElements = document.querySelectorAll(`.ingredient-package-amount[data-ingredient-id="${ingredientId}"]`);
                                if (packageAmountElements.length > 0) {
                                    console.debug(`Found ${packageAmountElements.length} package amount elements to update directly`);
                                    packageAmountElements.forEach(el => {
                                        el.textContent = window._lastPackageAmount;
                                        el.setAttribute('data-value', window._lastPackageAmount);
                                    });
                                }
                            }

                            // Force omega3 value to match what we sent
                            if (window._lastOmega3Value !== undefined) {
                                // CRITICAL FIX: Use omega3 (without underscore) to match database column name
                                console.debug('Forcing omega3 in the UI to match what was entered:', window._lastOmega3Value);
                                updatedIngredient.omega3 = window._lastOmega3Value;
                            }

                            // Force omega6 value to match what we sent
                            if (window._lastOmega6Value !== undefined) {
                                // CRITICAL FIX: Use omega6 (without underscore) to match database column name
                                console.debug('Forcing omega6 in the UI to match what was entered:', window._lastOmega6Value);
                                updatedIngredient.omega6 = window._lastOmega6Value;
                            }

                            // CRITICAL FIX: Make sure omega values are saved to OmegaStorage
                            if ((window._lastOmega3Value !== undefined) || (window._lastOmega6Value !== undefined)) {
                                try {
                                    if (window.OmegaStorage) {
                                        console.log('Ensuring omega values are saved to OmegaStorage...');
                                        const omega3Value = window._lastOmega3Value;
                                        const omega6Value = window._lastOmega6Value;

                                        // Save omega values to OmegaStorage
                                        const saveResult = window.OmegaStorage.saveOmegaValues(
                                            ingredientId,
                                            omega3Value,
                                            omega6Value
                                        );

                                        if (saveResult) {
                                            console.log('Omega values saved successfully to OmegaStorage');

                                            // Also update the ingredient object for immediate UI update
                                            // CRITICAL FIX: Use omega3 and omega6 (without underscores) to match database column names
                                            if (omega3Value !== undefined) {
                                                updatedIngredient.omega3 = omega3Value;
                                            }

                                            if (omega6Value !== undefined) {
                                                updatedIngredient.omega6 = omega6Value;
                                            }
                                        } else {
                                            console.error('Failed to save omega values to OmegaStorage');
                                        }
                                    } else {
                                        console.warn('OmegaStorage not available');
                                    }
                                } catch (error) {
                                    console.error('Error saving omega values to OmegaStorage:', error);
                                }
                            }
                        }

                        // Continue with the UI update using this data
                        if (recipeCard) {
                            const detailsDiv = recipeCard.querySelector('.ingredient-details');
                            const viewButton = recipeCard.querySelector('.view-ingredients-btn');

                            // Force a complete refresh of the ingredient details
                            if (detailsDiv) {
                                // Clear and show the details div
                                detailsDiv.innerHTML = '<p>Refreshing data...</p>';
                                detailsDiv.style.display = 'block';

                                // Update the button state
                                if (viewButton) {
                                    viewButton.textContent = 'Hide';
                                    viewButton.classList.add('active');
                                }

                                // Render the fresh data
                                renderIngredientDetails(freshRecipeData.ingredients, detailsDiv);
                            }
                        } else {
                            // Fallback to just updating the displayed ingredients
                            renderIngredientDetails(freshRecipeData.ingredients, container);
                        }

                        return; // Exit the function early since we've handled everything
                    }
                } catch (finalUpdateError) {
                    console.error('Error during final direct package amount update:', finalUpdateError);
                }

                // If the direct update failed, fall back to fetching the recipe
                console.debug('Falling back to fetching recipe data...');
                // Use safeFetch if available, otherwise fall back to regular fetch
                const fetchFunction = window.safeFetch || fetch;
                const freshResponse = await fetchFunction(`/api/recipes/${recipeId}?nocache=${new Date().getTime()}&force=true`);
                if (!freshResponse.ok) {
                    throw new Error(`HTTP error! status: ${freshResponse.status}`);
                }

                // Get the latest recipe data
                const freshRecipeData = await freshResponse.json();
                console.debug('Fresh recipe data from server received');

                // Log the updated package amounts for debugging
                freshRecipeData.ingredients.forEach(ing => {
                    console.debug(`Fresh data - Ingredient ${ing.name} package_amount:`, ing.package_amount);
                });

                // Find the ingredient that was just updated
                const updatedIngredient = freshRecipeData.ingredients.find(ing => ing.id == ingredientId);
                if (updatedIngredient) {
                    console.debug('Updated ingredient from fresh data:', updatedIngredient.name);
                    console.debug('Updated package_amount from fresh data:', updatedIngredient.package_amount);

                    // CRITICAL FIX: Force the package amount to match what we sent
                    // This ensures the UI shows the correct value even if the server didn't update it
                    if (window._lastPackageAmount !== undefined) {
                        console.debug('Forcing package amount in the UI to match what was entered:', window._lastPackageAmount);
                        updatedIngredient.package_amount = window._lastPackageAmount;

                        // Also update the DOM directly for any existing elements
                        const packageAmountElements = document.querySelectorAll(`.ingredient-package-amount[data-ingredient-id="${ingredientId}"]`);
                        if (packageAmountElements.length > 0) {
                            console.debug(`Found ${packageAmountElements.length} package amount elements to update directly`);
                            packageAmountElements.forEach(el => {
                                el.textContent = window._lastPackageAmount;
                                el.setAttribute('data-value', window._lastPackageAmount);
                            });
                        }
                    }

                    // Force omega3 value to match what we sent
                    if (window._lastOmega3Value !== undefined) {
                        // CRITICAL FIX: Use omega3 (without underscore) to match database column name
                        console.debug('Forcing omega3 in the UI to match what was entered:', window._lastOmega3Value);
                        updatedIngredient.omega3 = window._lastOmega3Value;
                    }

                    // Force omega6 value to match what we sent
                    if (window._lastOmega6Value !== undefined) {
                        // CRITICAL FIX: Use omega6 (without underscore) to match database column name
                        console.debug('Forcing omega6 in the UI to match what was entered:', window._lastOmega6Value);
                        updatedIngredient.omega6 = window._lastOmega6Value;
                    }

                    // CRITICAL FIX: Make sure omega values are saved to OmegaStorage
                    if ((window._lastOmega3Value !== undefined) || (window._lastOmega6Value !== undefined)) {
                        try {
                            if (window.OmegaStorage) {
                                console.log('Ensuring omega values are saved to OmegaStorage...');
                                const omega3Value = window._lastOmega3Value;
                                const omega6Value = window._lastOmega6Value;

                                // Save omega values to OmegaStorage
                                const saveResult = window.OmegaStorage.saveOmegaValues(
                                    ingredientId,
                                    omega3Value,
                                    omega6Value
                                );

                                if (saveResult) {
                                    console.log('Omega values saved successfully to OmegaStorage');

                                    // Also update the ingredient object for immediate UI update
                                    // CRITICAL FIX: Use omega3 and omega6 (without underscores) to match database column names
                                    if (omega3Value !== undefined) {
                                        updatedIngredient.omega3 = omega3Value;
                                    }

                                    if (omega6Value !== undefined) {
                                        updatedIngredient.omega6 = omega6Value;
                                    }
                                } else {
                                    console.error('Failed to save omega values to OmegaStorage');
                                }
                            } else {
                                console.warn('OmegaStorage not available');
                            }
                        } catch (error) {
                            console.error('Error saving omega values to OmegaStorage:', error);
                        }
                    }
                }

                if (recipeCard) {
                    const detailsDiv = recipeCard.querySelector('.ingredient-details');
                    const viewButton = recipeCard.querySelector('.view-ingredients-btn');

                    // Force a complete refresh of the ingredient details
                    if (detailsDiv) {
                        // Clear and show the details div
                        detailsDiv.innerHTML = '<p>Refreshing data...</p>';
                        detailsDiv.style.display = 'block';

                        // Update the button state
                        if (viewButton) {
                            viewButton.textContent = 'Hide';
                            viewButton.classList.add('active');
                        }

                        // Render the fresh data
                        renderIngredientDetails(freshRecipeData.ingredients, detailsDiv);
                    }
                } else {
                    // Fallback to just updating the displayed ingredients
                    renderIngredientDetails(freshRecipeData.ingredients, container);
                }
            } catch (refreshError) {
                console.debug('Error during forced refresh - falling back to existing data');
                // Fall back to using the data we already have
                renderIngredientDetails(updatedRecipe.ingredients, container);
            }

            // Hide the edit form if it exists
            const editForm = container.querySelector('.edit-ingredient-form');
            if (editForm) {
                editForm.style.display = 'none';
            }

            // Update the recipe calories display
            const recipeItem = container.closest('.recipe-display-item');
            const caloriesSpan = recipeItem.querySelector('.recipe-calories');
            if (caloriesSpan) {
                caloriesSpan.textContent = updatedRecipe.total_calories.toFixed(1);
            }

            showStatus(statusElement, 'Ingredient updated successfully!', 'success');

        } catch (error) {
            console.debug('Error updating ingredient - UI update will still be applied');
            showStatus(statusElement, `Ingredient updated in UI (server update may have failed)`, 'info');
        }
    }

    // Event delegation for recipe list actions (Delete, Adjust, View)
    recipeListContainer.addEventListener('click', async (event) => { // Make async for await
        const target = event.target;
        const recipeItem = target.closest('.recipe-card'); // Updated selector for new layout
        if (!recipeItem) return; // Click wasn't inside a recipe item

        const recipeId = recipeItem.dataset.id;
        const currentCaloriesSpan = recipeItem.querySelector('.recipe-card-calories');
        const currentCaloriesText = currentCaloriesSpan?.textContent || '0';
        // Extract just the number from "1500.0 calories" format
        const currentCalories = parseFloat(currentCaloriesText.replace(/[^0-9.]/g, ''));

        if (target.classList.contains('delete-recipe-btn')) {
            deleteRecipe(recipeId);
        }
        // --- Calorie Adjustment Handlers ---
        else if (target.classList.contains('adjust-calories-btn')) {
            const targetInput = recipeItem.querySelector('.target-calories-input');
            const targetCalories = parseFloat(targetInput?.value);
            if (!isNaN(targetCalories) && targetCalories > 0) {
                await adjustRecipeCalories(recipeId, targetCalories, recipeItem);
            } else {
                 showStatus(recipeItem.querySelector('.adjustment-status'), 'Please enter a valid positive number for calories.', 'error');
            }
        }
        else if (target.classList.contains('adjust-calories-percent-btn')) {
            const percent = parseFloat(target.dataset.percent);
             if (!isNaN(percent) && currentCalories > 0) {
                 const targetCalories = currentCalories * percent;
                 await adjustRecipeCalories(recipeId, targetCalories, recipeItem);
             } else {
                 showStatus(recipeItem.querySelector('.adjustment-status'), 'Cannot adjust by percent if current calories are zero.', 'error');
             }
        }
        else if (target.classList.contains('adjust-calories-amount-btn')) {
            const amount = parseFloat(target.dataset.amount);
            if (!isNaN(amount)) {
                const targetCalories = Math.max(1, currentCalories + amount); // Ensure calories don't go below 1
                 await adjustRecipeCalories(recipeId, targetCalories, recipeItem);
            } else {
                 showStatus(recipeItem.querySelector('.adjustment-status'), 'Invalid adjustment amount.', 'error');
            }
        }
         // --- View Ingredients Handler ---
        else if (target.classList.contains('view-ingredients-btn')) {
            const detailsDiv = recipeItem.querySelector('.ingredient-details');
            await fetchAndDisplayIngredients(recipeId, detailsDiv, target); // Pass button to toggle text
        }
    });

    // --- Add Event Listener for Weight Goal Form --- //
    if (weightGoalForm) { // Ensure the form exists before adding listener
        weightGoalForm.addEventListener('submit', saveWeightGoal);
    } else {
        console.error("Could not find weight goal form element (#weight-goal-form) to attach listener.");
    }

    // --- Add Event Listener for User Selector --- //
    if (userSelector) {
        userSelector.addEventListener('change', function() {
            currentUserId = this.value; // Update the current user ID
            console.log(`Switched to user ID: ${currentUserId}`);

            // Save the user preference to localStorage
            localStorage.setItem('weightUserPreference', currentUserId);

            // Reload data for the selected user
            loadWeightGoal();

            // Destroy existing chart before loading new data
            if (weightGoalChart) {
                weightGoalChart.destroy();
                weightGoalChart = null;
            }

            // Load and render the chart with the new user data
            console.log(`Loading chart data for user ID: ${currentUserId}`);
            loadAndRenderWeightChart();

            // Update the user selector label
            const userLabel = currentUserId == 1 ? 'My Data' : 'Mom\'s Data';
            showStatus(weightGoalStatus, `Switched to ${userLabel}`, 'info');
            setTimeout(() => showStatus(weightGoalStatus, '', ''), 2000); // Clear after 2 seconds
        });
    } else {
        console.error("Could not find user selector element (#user-selector) to attach listener.");
    }

    // --- Add Event Listeners for Axis Scale Controls --- //

    // X-Axis Scale Slider
    if (xAxisScaleSlider) {
        xAxisScaleSlider.addEventListener('input', function() {
            xAxisScale = parseFloat(this.value);
            xScaleValue.textContent = xAxisScale.toFixed(1) + 'x';
            console.log(`X-axis scale set to ${xAxisScale}x`);
            if (weightGoalChart) {
                // Update the chart's x-axis min and max
                const chart = weightGoalChart;
                const dataLength = chart.data.labels.length;

                if (dataLength <= 1) {
                    // Not enough data points to scale
                    return;
                }

                // Calculate the visible range based on the scale
                // For values < 1: Show more data points (zoom out)
                // For values > 1: Show fewer data points (zoom in)
                let visiblePoints;

                // Base calculation on the total data length and scale
                if (xAxisScale <= 1) {
                    // Zoom out (show more data)
                    // When scale is very small, show more than the available data points
                    // to allow for future projections and past data
                    const extraPoints = Math.round((1 - xAxisScale) * 10); // Add extra points as scale decreases
                    visiblePoints = Math.min(dataLength * 2, Math.round(dataLength / xAxisScale) + extraPoints);
                } else {
                    // Zoom in (show less data)
                    visiblePoints = Math.max(5, Math.round(dataLength / xAxisScale));
                }

                // Always show all data points plus extra when scale is at minimum
                if (xAxisScale === 0.1) {
                    visiblePoints = dataLength * 2; // Show twice as many points as we have data
                }

                // Ensure we always show at least 2 weeks of data (14 points)
                visiblePoints = Math.max(visiblePoints, 14);

                console.log(`X-axis scale: ${xAxisScale}, Data length: ${dataLength}, Visible points: ${visiblePoints}`);

                // Find today's index or the most recent data point
                let todayIndex = -1;
                const today = new Date().toLocaleDateString();

                // First try to find exact match for today
                for (let i = 0; i < chart.data.labels.length; i++) {
                    const labelDate = new Date(chart.data.labels[i]).toLocaleDateString();
                    if (labelDate === today) {
                        todayIndex = i;
                        break;
                    }
                }

                // If today not found, use the most recent data point
                if (todayIndex === -1) {
                    todayIndex = dataLength - 1;
                }

                // Calculate the center point for our view
                const centerIndex = todayIndex;

                // Calculate min and max indices centered around today/most recent point
                // Allow for negative minIndex and maxIndex beyond dataLength to show past/future dates
                let minIndex = centerIndex - Math.floor(visiblePoints / 2);
                let maxIndex = minIndex + visiblePoints - 1;

                // When zoomed out (scale < 1), allow showing dates beyond the available data
                // This enables seeing future projections and past data
                if (xAxisScale < 1) {
                    // Allow negative minIndex (past dates before first data point)
                    // and maxIndex beyond dataLength (future dates after last data point)

                    // Ensure we're centered around today/most recent point
                    minIndex = centerIndex - Math.floor(visiblePoints / 2);
                    maxIndex = minIndex + visiblePoints - 1;

                    // Add extra padding for future dates when zoomed out
                    const futurePadding = Math.round((1 - xAxisScale) * 10);
                    maxIndex += futurePadding;
                } else {
                    // When zoomed in, ensure we stay within data boundaries
                    minIndex = Math.max(0, minIndex);
                    maxIndex = Math.min(dataLength - 1, maxIndex);

                    // If we hit the right boundary, adjust the left boundary
                    if (maxIndex === dataLength - 1 && minIndex > 0) {
                        minIndex = Math.max(0, dataLength - visiblePoints);
                    }

                    // If we hit the left boundary, adjust the right boundary
                    if (minIndex === 0 && maxIndex < dataLength - 1) {
                        maxIndex = Math.min(dataLength - 1, visiblePoints - 1);
                    }
                }

                console.log(`X-axis range: ${minIndex} to ${maxIndex} (${maxIndex - minIndex + 1} points)`);

                // Add margin to the left side of the chart (1 extra point)
                let adjustedMinIndex = minIndex - 1;

                // Set the min and max for the x-axis
                chart.options.scales.x.min = adjustedMinIndex;
                chart.options.scales.x.max = maxIndex;

                // IMPORTANT: Temporarily disable annotations during x-axis scaling
                let originalAnnotationConfig = null;

                // Safely backup and remove annotation plugin
                if (chart.options.plugins && chart.options.plugins.annotation) {
                    try {
                        // Store the original annotation configuration
                        originalAnnotationConfig = chart.options.plugins.annotation;

                        // Completely remove the annotation plugin during the update
                        delete chart.options.plugins.annotation;
                    } catch (error) {
                        console.error('Error backing up annotations during x-axis scaling:', error);
                        // If we can't backup, just remove the annotation plugin
                        delete chart.options.plugins.annotation;
                    }
                }

                // Disable animations during scale changes
                chart.options.animation = false;

                try {
                    // First update without annotations
                    chart.update('none');

                    // If we had annotations before, restore them after the update
                    if (originalAnnotationConfig) {
                        // Wait a short time before re-enabling annotations
                        setTimeout(() => {
                            try {
                                // Restore the annotation plugin with the original configuration
                                chart.options.plugins.annotation = originalAnnotationConfig;

                                // Update again with annotations, but with animations disabled
                                chart.update('none');
                            } catch (annotationError) {
                                console.error('Error restoring annotations after x-axis scaling:', annotationError);
                                // If restoring annotations fails, continue without them
                            }
                        }, 300); // Increased timeout to ensure chart is fully updated first
                    }
                } catch (error) {
                    console.error('Error updating chart during x-axis scaling:', error);
                    // If update fails, try a simpler update
                    chart.update();
                }
            }
        });

        // Also add change event for when slider is released
        xAxisScaleSlider.addEventListener('change', function() {
            // This event fires when the slider is released
            // Force a more aggressive update
            if (weightGoalChart) {
                const chart = weightGoalChart;
                const dataLength = chart.data.labels.length;

                if (dataLength <= 1) {
                    // Not enough data points to scale
                    return;
                }

                // Force update with the final scale value
                console.log(`X-axis scale finalized at ${xAxisScale}x`);

                // Recalculate everything and update
                // This is the same code as in the input event, but we call it again to ensure it takes effect
                // Calculate the visible range based on the scale
                let visiblePoints;
                if (xAxisScale <= 1) {
                    const extraPoints = Math.round((1 - xAxisScale) * 10);
                    visiblePoints = Math.min(dataLength * 2, Math.round(dataLength / xAxisScale) + extraPoints);
                } else {
                    visiblePoints = Math.max(5, Math.round(dataLength / xAxisScale));
                }

                if (xAxisScale === 0.1) {
                    visiblePoints = dataLength * 2;
                }

                visiblePoints = Math.max(visiblePoints, 14);

                // Find today's index or the most recent data point
                let todayIndex = -1;
                const today = new Date().toLocaleDateString();

                for (let i = 0; i < chart.data.labels.length; i++) {
                    const labelDate = new Date(chart.data.labels[i]).toLocaleDateString();
                    if (labelDate === today) {
                        todayIndex = i;
                        break;
                    }
                }

                if (todayIndex === -1) {
                    todayIndex = dataLength - 1;
                }

                const centerIndex = todayIndex;

                // Calculate min and max indices
                let minIndex = centerIndex - Math.floor(visiblePoints / 2);
                let maxIndex = minIndex + visiblePoints - 1;

                if (xAxisScale < 1) {
                    minIndex = centerIndex - Math.floor(visiblePoints / 2);
                    maxIndex = minIndex + visiblePoints - 1;

                    const futurePadding = Math.round((1 - xAxisScale) * 10);
                    maxIndex += futurePadding;
                } else {
                    minIndex = Math.max(0, minIndex);
                    maxIndex = Math.min(dataLength - 1, maxIndex);

                    if (maxIndex === dataLength - 1 && minIndex > 0) {
                        minIndex = Math.max(0, dataLength - visiblePoints);
                    }

                    if (minIndex === 0 && maxIndex < dataLength - 1) {
                        maxIndex = Math.min(dataLength - 1, visiblePoints - 1);
                    }
                }

                let adjustedMinIndex = minIndex - 1;

                chart.options.scales.x.min = adjustedMinIndex;
                chart.options.scales.x.max = maxIndex;

                // IMPORTANT: Temporarily disable annotations during x-axis scaling
                let originalAnnotationConfig = null;

                // Safely backup and remove annotation plugin
                if (chart.options.plugins && chart.options.plugins.annotation) {
                    try {
                        // Store the original annotation configuration
                        originalAnnotationConfig = chart.options.plugins.annotation;

                        // Completely remove the annotation plugin during the update
                        delete chart.options.plugins.annotation;
                    } catch (error) {
                        console.error('Error backing up annotations during x-axis scaling:', error);
                        // If we can't backup, just remove the annotation plugin
                        delete chart.options.plugins.annotation;
                    }
                }

                // Disable animations during scale changes
                chart.options.animation = false;

                try {
                    // First update without annotations
                    chart.update('none');

                    // If we had annotations before, restore them after the update
                    if (originalAnnotationConfig) {
                        // Wait a short time before re-enabling annotations
                        setTimeout(() => {
                            try {
                                // Restore the annotation plugin with the original configuration
                                chart.options.plugins.annotation = originalAnnotationConfig;

                                // Update again with annotations, but with animations disabled
                                chart.update('none');
                            } catch (annotationError) {
                                console.error('Error restoring annotations after x-axis scaling:', annotationError);
                                // If restoring annotations fails, continue without them
                            }
                        }, 300); // Increased timeout to ensure chart is fully updated first
                    }
                } catch (error) {
                    console.error('Error updating chart during x-axis scaling:', error);
                    // If update fails, try a simpler update
                    chart.update();
                }
            }
        });
    } else {
        console.error("Could not find x-axis scale slider element (#x-axis-scale) to attach listener.");
    }

    // Y-Axis Scale Slider
    if (yAxisScaleSlider) {
        // Function to calculate and set y-axis min/max based on scale
        function updateChartYAxisScale(chart, scale, animate = false) {
            if (!chart || !chart.data || !chart.data.datasets || chart.data.datasets.length === 0) {
                return;
            }

            // On initial load, use scale=1 to ensure proper display
            if (scale !== 1 && !chart._initialScaleApplied) {
                console.log('Forcing initial scale to 1.0x for first render');
                scale = 1.0;
                chart._initialScaleApplied = true;
            }

            // Find min and max data points
            let minDataPoint = Number.MAX_VALUE;
            let maxDataPoint = Number.MIN_VALUE;
            const validPoints = [];

            // Collect all valid data points
            chart.data.datasets.forEach(dataset => {
                if (dataset.data && Array.isArray(dataset.data)) {
                    dataset.data.forEach(point => {
                        // Handle different data formats
                        let yValue = null;

                        if (typeof point === 'number') {
                            // Simple number format
                            yValue = point;
                        } else if (point && typeof point === 'object') {
                            // Object format with y property
                            yValue = point.y;
                        }

                        if (yValue !== null && yValue !== undefined && !isNaN(yValue)) {
                            validPoints.push(yValue);
                            if (yValue < minDataPoint) minDataPoint = yValue;
                            if (yValue > maxDataPoint) maxDataPoint = yValue;
                        }
                    });
                }
            });

            // If no valid data points, return
            if (minDataPoint === Number.MAX_VALUE || validPoints.length === 0) {
                console.warn('No valid data points found for y-axis scaling');
                return;
            }

            // Calculate the range of the data
            const dataRange = maxDataPoint - minDataPoint;

            // Add a minimum range to prevent division by zero or tiny ranges
            const effectiveRange = Math.max(dataRange, 0.1);

            // Calculate the center of the data range
            const dataCenter = (maxDataPoint + minDataPoint) / 2;

            // Calculate the scaled range based on the scale factor
            let scaledRange;

            if (scale <= 1) {
                // Zoom out (show more data)
                scaledRange = effectiveRange / scale;

                // Add extra padding when zoomed out
                const extraPadding = effectiveRange * (1 - scale) * 0.5;
                scaledRange += extraPadding;
            } else {
                // Zoom in (show less data)
                scaledRange = effectiveRange / scale;
                console.log(`Y-axis zoom in: scale=${scale}, range=${effectiveRange}, scaledRange=${scaledRange}`);
            }

            // Ensure we have a reasonable minimum range (at least 5 units)
            scaledRange = Math.max(scaledRange, 5);

            // Log the calculation for debugging
            console.log(`Y-axis scale: ${scale}, Data range: ${effectiveRange}, Scaled range: ${scaledRange}`);

            // Calculate the new min/max based on the scaled range
            const topPadding = effectiveRange * 0.05; // 5% padding at top
            const bottomPadding = effectiveRange * 0.15; // 15% padding at bottom

            const calculatedMin = dataCenter - (scaledRange / 2) - bottomPadding;
            const calculatedMax = dataCenter + (scaledRange / 2) + topPadding;

            // Add extra padding at the bottom to ensure points don't go below view
            const extraBottomPadding = effectiveRange * 0.15; // 15% extra padding at bottom
            const finalMin = calculatedMin - extraBottomPadding;

            // Ensure there's always a minimum visible range, even with high zoom
            const minVisibleRange = maxDataPoint * 0.1; // At least 10% of max value
            const adjustedMin = (calculatedMax - finalMin < minVisibleRange) ?
                calculatedMax - minVisibleRange : finalMin;

            // IMPORTANT: Completely disable annotations during scaling to prevent errors
            // Store the original annotation configuration to restore it later
            let originalAnnotationConfig = null;

            // Safely backup and remove annotation plugin
            if (chart.options.plugins && chart.options.plugins.annotation) {
                try {
                    // Store the original annotation configuration
                    originalAnnotationConfig = chart.options.plugins.annotation;

                    // Completely remove the annotation plugin during the update
                    delete chart.options.plugins.annotation;
                } catch (error) {
                    console.error('Error backing up annotations:', error);
                    // If we can't backup, just remove the annotation plugin
                    delete chart.options.plugins.annotation;
                }
            }

            // Update the chart's y-axis min/max
            chart.options.scales.y.min = adjustedMin; // Use adjustedMin with extra bottom padding
            chart.options.scales.y.max = calculatedMax;

            // Disable animations during scale changes to prevent visual glitches
            chart.options.animation = false;

            try {
                // First update without annotations
                chart.update('none');

                // If we had annotations before, restore them after the update
                if (originalAnnotationConfig) {
                    // Wait a short time before re-enabling annotations
                    setTimeout(() => {
                        try {
                            // Restore the annotation plugin with the original configuration
                            chart.options.plugins.annotation = originalAnnotationConfig;

                            // Update again with annotations, but with animations disabled
                            chart.update('none');
                        } catch (annotationError) {
                            console.error('Error restoring annotations:', annotationError);
                            // If restoring annotations fails, continue without them
                        }
                    }, 300); // Increased timeout to ensure chart is fully updated first
                }
            } catch (error) {
                console.error('Error updating chart:', error);

                // If the update fails, try a more aggressive approach
                try {
                    // Disable all plugins temporarily
                    const originalPlugins = {...chart.options.plugins};
                    chart.options.plugins = {};

                    // Update with minimal configuration
                    chart.update('none');

                    // Restore original plugins except annotation
                    const cleanPlugins = {...originalPlugins};
                    delete cleanPlugins.annotation; // Ensure annotation is removed
                    chart.options.plugins = cleanPlugins;

                    // Final update with clean plugins
                    chart.update('none');
                } catch (fallbackError) {
                    console.error('Fallback update also failed:', fallbackError);
                }
            }
        }

        // Handle slider input (during drag)
        yAxisScaleSlider.addEventListener('input', function() {
            yAxisScale = parseFloat(this.value);
            yScaleValue.textContent = yAxisScale.toFixed(1) + 'x';

            if (weightGoalChart) {
                // Update the chart with the new scale (no animation during drag)
                updateChartYAxisScale(weightGoalChart, yAxisScale, false);
                console.log(`Y-axis scale set to ${yAxisScale}x`);
            }
        });

        // Handle slider change (on release)
        yAxisScaleSlider.addEventListener('change', function() {
            if (weightGoalChart) {
                // Update the chart with the new scale (with animation on release)
                updateChartYAxisScale(weightGoalChart, yAxisScale, true);
                console.log(`Y-axis scale finalized at ${yAxisScale}x`);
            }
        });
    } else {
        console.error("Could not find y-axis scale slider element (#y-axis-scale) to attach listener.");
    }

    // Reset Scale Button
    if (resetScaleButton) {
        resetScaleButton.addEventListener('click', function() {
            // Reset both sliders to default value (1)
            xAxisScaleSlider.value = 1;
            yAxisScaleSlider.value = 1;
            xAxisScale = 1;
            yAxisScale = 1;
            xScaleValue.textContent = '1.0x';
            yScaleValue.textContent = '1.0x';

            if (weightGoalChart) {
                // Reset the chart's axes to show all data
                const chart = weightGoalChart;

                // Reset x-axis limits to show all data
                if (chart.options.scales.x) {
                    chart.options.scales.x.min = 0;
                    chart.options.scales.x.max = chart.data.labels.length - 1;
                }

                // Find min and max data points for y-axis
                let minDataPoint = Number.MAX_VALUE;
                let maxDataPoint = Number.MIN_VALUE;

                // Collect all valid data points
                chart.data.datasets.forEach(dataset => {
                    dataset.data.forEach(point => {
                        if (point && point.y !== null && point.y !== undefined && !isNaN(point.y)) {
                            if (point.y < minDataPoint) minDataPoint = point.y;
                            if (point.y > maxDataPoint) maxDataPoint = point.y;
                        }
                    });
                });

                // If we have valid data points, set the y-axis range with generous padding
                if (minDataPoint !== Number.MAX_VALUE && maxDataPoint !== Number.MIN_VALUE) {
                    const dataRange = maxDataPoint - minDataPoint;
                    const topPadding = dataRange * 0.05; // 5% padding at top
                    const bottomPadding = dataRange * 0.15; // 15% padding at bottom

                    // Add extra padding at the bottom to ensure points don't go below view
                    const extraBottomPadding = dataRange * 0.15; // 15% extra padding

                    // Reset y-axis limits to show all data with padding
                    const calculatedMin = minDataPoint - bottomPadding - extraBottomPadding;
                    const calculatedMax = maxDataPoint + topPadding;

                    // Ensure there's always a minimum visible range
                    const minVisibleRange = maxDataPoint * 0.1; // At least 10% of max value
                    const adjustedMin = (calculatedMax - calculatedMin < minVisibleRange) ?
                        calculatedMax - minVisibleRange : calculatedMin;

                    chart.options.scales.y.min = adjustedMin;
                    chart.options.scales.y.max = calculatedMax;
                } else {
                    // If no valid data points, use undefined to let Chart.js decide
                    chart.options.scales.y.min = undefined;
                    chart.options.scales.y.max = undefined;
                }

                // Add a brief animation for the reset
                chart.options.animation = {
                    duration: 500,
                    easing: 'easeOutQuad'
                };

                // Save current annotations
                let hasAnnotations = false;
                let safeAnnotations = null;

                // Safely extract annotation configuration
                if (chart.options.plugins && chart.options.plugins.annotation &&
                    chart.options.plugins.annotation.annotations) {
                    hasAnnotations = true;

                    // Create a clean copy of annotations
                    safeAnnotations = {};
                    const originalAnnotations = chart.options.plugins.annotation.annotations;

                    // Only copy the essential properties to avoid reference issues
                    if (originalAnnotations.todayIndicator) {
                        safeAnnotations.todayIndicator = {
                            type: 'line',
                            scaleID: 'x',
                            value: originalAnnotations.todayIndicator.value,
                            borderColor: 'rgba(255, 99, 132, 0.8)',
                            borderWidth: 2,
                            borderDash: [6, 6],
                            label: {
                                display: true,
                                content: 'Today',
                                position: 'start',
                                backgroundColor: 'rgba(255, 99, 132, 0.8)',
                                font: { weight: 'bold' }
                            }
                        };
                    }

                    if (originalAnnotations.targetWeightLine) {
                        safeAnnotations.targetWeightLine = {
                            type: 'line',
                            scaleID: 'y',
                            value: originalAnnotations.targetWeightLine.value,
                            borderColor: 'rgba(54, 162, 235, 0.8)',
                            borderWidth: 2,
                            borderDash: [6, 6],
                            label: {
                                display: true,
                                content: 'Target: ' + originalAnnotations.targetWeightLine.value + ' lbs',
                                position: 'end',
                                backgroundColor: 'rgba(54, 162, 235, 0.8)',
                                font: { weight: 'bold' }
                            }
                        };
                    }

                    // Temporarily remove annotations
                    chart.options.plugins.annotation = false;
                }

                // IMPORTANT: Completely disable annotations during reset to prevent errors
                let originalAnnotationConfig = null;

                // Safely backup and remove annotation plugin
                if (chart.options.plugins && chart.options.plugins.annotation) {
                    try {
                        // Store the original annotation configuration
                        originalAnnotationConfig = chart.options.plugins.annotation;

                        // Completely remove the annotation plugin during the update
                        delete chart.options.plugins.annotation;
                    } catch (error) {
                        console.error('Error backing up annotations during reset:', error);
                        // If we can't backup, just remove the annotation plugin
                        delete chart.options.plugins.annotation;
                    }
                }

                // Perform a complete reset and update
                chart.reset();
                chart.update('none');

                // Re-add annotations after the update if they existed
                if (hasAnnotations && safeAnnotations) {
                    try {
                        // Wait a short time before re-enabling annotations
                        setTimeout(() => {
                            try {
                                // Re-enable annotation plugin with safe configuration
                                chart.options.plugins.annotation = {
                                    annotations: safeAnnotations,
                                    clip: false,
                                    interaction: { mode: 'nearest' },
                                    animations: { duration: 0 }
                                };

                                // Do a final update with annotations
                                chart.update('none');
                            } catch (annotationError) {
                                console.error('Error re-enabling annotations during reset:', annotationError);
                                // Continue without annotations if there's an error
                            }
                        }, 100);
                    } catch (annotationError) {
                        console.error('Error scheduling annotation update during reset:', annotationError);
                    }
                }

                console.log('Chart scales reset to default (1.0x)');
            }
        });
    } else {
        console.error("Could not find reset scale button element (#reset-scale-button) to attach listener.");
    }

    // --- Calorie Target Functions --- //

    // Save calorie target for the selected user
    async function saveCalorieTarget() {
        const userId = calorieUserSelector.value;
        const calorieTarget = parseInt(calorieTargetInput.value);

        if (isNaN(calorieTarget) || calorieTarget < 500 || calorieTarget > 10000) {
            showStatus(calorieTargetStatus, 'Please enter a valid calorie target between 500 and 10000.', 'error');
            return;
        }

        showStatus(calorieTargetStatus, 'Saving calorie target...', 'info');

        try {
            console.log(`Attempting to save calorie target for user ${userId}: ${calorieTarget} calories`);

            // First try the dedicated calorie targets API
            let response = await fetch('/api/calorie-targets', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    user_id: userId,
                    daily_target: calorieTarget
                })
            });
            console.log(`Received response with status: ${response.status}`);

            // If the API returns 404, try the weight API endpoint
            if (response.status === 404) {
                console.log('Calorie targets API not found, trying weight API endpoint');
                response = await fetch('/api/weight/calorie-targets', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: userId,
                        daily_target: calorieTarget
                    })
                });
                console.log(`Received response from weight API with status: ${response.status}`);
            }

            if (!response.ok) {
                let errorMessage = `HTTP error! status: ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.error || errorMessage;
                } catch (e) {
                    console.error('Could not parse error response:', e);
                }
                throw new Error(errorMessage);
            }

            const result = await response.json();
            console.log('Save result:', result);
            showStatus(calorieTargetStatus, 'Calorie target saved successfully!', 'success');

            // Update the displayed current target
            loadCalorieTarget(userId);

            // Clear the input
            calorieTargetInput.value = '';

        } catch (error) {
            console.error('Error saving calorie target:', error);
            showStatus(calorieTargetStatus, `Error saving calorie target: ${error.message}`, 'error');

            // Still update the display to show the current value
            setTimeout(() => {
                loadCalorieTarget(userId);
            }, 2000);
        }
    }

    // Load calorie target for the specified user
    async function loadCalorieTarget(userId) {
        try {
            console.log(`Attempting to fetch calorie target for user ${userId}`);

            // First try the dedicated calorie targets API
            let response = await fetch(`/api/calorie-targets/${userId}`);
            console.log(`Received response with status: ${response.status}`);

            // If the API returns 404, try the weight API endpoint
            if (response.status === 404) {
                // Try the weight API endpoint
                try {
                    console.log('Calorie targets API not found or no target, trying weight API endpoint');
                    response = await fetch(`/api/weight/calorie-targets/${userId}`);
                    console.log(`Received response from weight API with status: ${response.status}`);
                } catch (weightApiError) {
                    console.error('Error fetching from weight API:', weightApiError);
                }
            }

            if (response.status === 404) {
                // No target set for this user in either API
                console.log('No calorie target found for this user');
                currentCalorieTarget.textContent = 'Not set';
                return;
            }

            if (!response.ok) {
                let errorMessage = `HTTP error! status: ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.error || errorMessage;
                } catch (e) {
                    console.error('Could not parse error response:', e);
                }
                throw new Error(errorMessage);
            }

            const data = await response.json();
            console.log('Calorie target data:', data);

            // Handle different response formats
            const dailyTarget = data.daily_target || data.target || data.calories || data.value;

            if (dailyTarget) {
                currentCalorieTarget.textContent = `${dailyTarget} calories`;
            } else {
                console.warn('Unexpected calorie target data format:', data);
                currentCalorieTarget.textContent = 'Not set';
            }

        } catch (error) {
            console.error('Error loading calorie target:', error);
            currentCalorieTarget.textContent = 'Not set'; // Default to 'Not set' instead of error
        }
    }

    // Event listener for the save calorie target button
    if (saveCalorieTargetBtn) {
        saveCalorieTargetBtn.addEventListener('click', saveCalorieTarget);
    }

    // Event listener for the calorie user selector
    if (calorieUserSelector) {
        calorieUserSelector.addEventListener('change', function() {
            const userId = this.value;
            loadCalorieTarget(userId);
        });
    }

    // Quick target buttons have been removed

    // Event listener for the user selector (weight goals)
    if (userSelector) {
        userSelector.addEventListener('change', function() {
            // Update the current user ID
            currentUserId = this.value;

            // Save the preference to localStorage
            localStorage.setItem('weightUserPreference', currentUserId);

            // Sync the calorie user selector with the main user selector
            if (calorieUserSelector) {
                calorieUserSelector.value = this.value;
                // Also load the calorie target for the new user
                loadCalorieTarget(this.value);
            }

            // Destroy the current chart to prevent tooltip issues
            if (weightGoalChart) {
                weightGoalChart.destroy();
                weightGoalChart = null;
            }

            // Load data for the new user
            loadWeightGoal();
            loadAndRenderWeightChart();

            // Fix tooltips after chart is reloaded
            setTimeout(fixTooltips, 1000);

            console.log(`Switched to user ID: ${currentUserId}`);
        });
    }

    // Function to ensure tooltips work properly
    function fixTooltips() {
        if (!weightGoalChart || !weightGoalChartCanvas) return;

        // Re-attach custom tooltip events
        if (window.attachWeightChartTooltipEvents) {
            window.attachWeightChartTooltipEvents(weightGoalChart);
            console.log('Re-attached custom tooltip events to chart');
        } else {
            console.error('Custom tooltip functions not available');
        }
    }

    // --- Initial Load --- //
    loadWeightGoal(); // Load saved goal
    loadAndRenderWeightChart(); // Attempt to load chart data
    loadRecipes();
    loadCalorieTarget(calorieUserSelector.value); // Load calorie target for the default user

    // Fix tooltips after a short delay to ensure chart is fully rendered
    setTimeout(fixTooltips, 1000);

    // Function to show the add ingredient form
    window.showAddIngredientForm = function(recipeId, container) {
        console.log(`Showing add ingredient form for recipe ${recipeId}`);

        if (!container) {
            console.error('Container not provided to showAddIngredientForm');
            return;
        }

        // Show the add ingredient form
        const ingredientAddForm = container.querySelector('.add-ingredient-form');
        if (!ingredientAddForm) {
            console.error('Add ingredient form not found in container');
            return;
        }

        // Set the recipe ID in the form
        const recipeIdInput = document.getElementById('add-ingredient-recipe-id');
        if (recipeIdInput) {
            recipeIdInput.value = recipeId;
        } else {
            console.error('Recipe ID input not found in add ingredient form');
        }

        // Load existing ingredients for the dropdown
        if (typeof loadExistingIngredients === 'function') {
            loadExistingIngredients();
        } else if (typeof window.loadExistingIngredients === 'function') {
            window.loadExistingIngredients();
        } else {
            console.warn('loadExistingIngredients function not available');
        }

        // Show the form
        ingredientAddForm.style.display = 'block';

        // Initialize the Cronometer text parser for the form
        if (typeof initializeCronometerTextParser === 'function') {
            console.log('Initializing Cronometer text parser for add ingredient form');
            initializeCronometerTextParser(ingredientAddForm);
        } else if (typeof window.initializeCronometerTextParser === 'function') {
            console.log('Initializing Cronometer text parser for add ingredient form (using window scope)');
            window.initializeCronometerTextParser(ingredientAddForm);
        } else {
            console.warn('Cronometer text parser not available for add form');
        }

        // Scroll to the form
        ingredientAddForm.scrollIntoView({ behavior: 'smooth', block: 'start' });
    };

    // Function to show the edit ingredient form
    window.showEditIngredientForm = function(recipeId, ingredientId, container) {
        console.log(`Showing edit ingredient form for ingredient ${ingredientId} in recipe ${recipeId}`);

        if (!container) {
            console.error('Container not provided to showEditIngredientForm');
            return;
        }

        const editForm = container.querySelector('.edit-ingredient-form');
        if (!editForm) {
            console.error('Edit ingredient form not found in container');
            return;
        }

        const statusElement = container.querySelector('.edit-ingredient-status');

        // Show the edit form
        editForm.style.display = 'block';

        // Initialize the Cronometer text parser for the form
        if (typeof initializeCronometerTextParser === 'function') {
            console.log('Initializing Cronometer text parser for edit ingredient form');
            initializeCronometerTextParser(editForm);
        } else if (typeof window.initializeCronometerTextParser === 'function') {
            console.log('Initializing Cronometer text parser for edit ingredient form (using window scope)');
            window.initializeCronometerTextParser(editForm);
        } else {
            console.warn('Cronometer text parser not available for edit form');
        }

        // IMPORTANT: Check if we have a UI-updated value for this ingredient
        // This ensures the edit form shows the most recent value even if the database hasn't been updated
        const packageAmountElement = container.querySelector(`[data-ingredient-id="${ingredientId}"]`);
        let uiPackageAmount = null;
        if (packageAmountElement) {
            uiPackageAmount = packageAmountElement.getAttribute('data-value');
            console.debug(`Found UI-updated package amount: ${uiPackageAmount}`);
        }

        // Fetch the full ingredient data from the API
        fetch(`/api/recipes/${recipeId}/ingredients/${ingredientId}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(ingredient => {
                // Log the ingredient data to see what's being returned
                console.debug('Ingredient data from API:', ingredient);

                // If we have a UI-updated value, override the database value
                if (uiPackageAmount !== null) {
                    console.debug(`Overriding database package amount (${ingredient.package_amount}) with UI value (${uiPackageAmount})`);
                    ingredient.package_amount = parseFloat(uiPackageAmount);
                }

                // Populate form fields with current values
                document.getElementById('edit-ingredient-id').value = ingredientId;
                document.getElementById('edit-recipe-id').value = recipeId;

                // Populate all the form fields with the ingredient data
                if (typeof populateEditForm === 'function') {
                    populateEditForm(ingredient);
                } else if (typeof window.populateEditForm === 'function') {
                    window.populateEditForm(ingredient);
                } else {
                    console.error('populateEditForm function not available');
                }

                // Clear any previous status messages
                if (statusElement) {
                    showStatus(statusElement, '', '');
                }

                // Scroll to the edit form
                editForm.scrollIntoView({ behavior: 'smooth' });
            })
            .catch(error => {
                console.error('Error fetching ingredient details:', error);
                if (statusElement) {
                    showStatus(statusElement, `Error loading ingredient: ${error.message}`, 'error');
                }
            });
    };

    // Function to load existing ingredients for the dropdown
    async function loadExistingIngredients() {
        const select = document.getElementById('existing-ingredient-select');
        if (!select) return;

        // Clear existing options except the first one
        while (select.options.length > 1) {
            select.remove(1);
        }

        // Set loading state
        select.options[0].text = 'Loading ingredients...';

        try {
            // Get all recipes to extract unique ingredients
            const response = await fetch('/api/recipes');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const recipes = await response.json();
            const uniqueIngredients = new Map(); // Use Map to store unique ingredients by name

            // Extract all ingredients from all recipes
            recipes.forEach(recipe => {
                if (recipe.ingredients && Array.isArray(recipe.ingredients)) {
                    recipe.ingredients.forEach(ingredient => {
                        // Use ingredient name as key to avoid duplicates
                        if (!uniqueIngredients.has(ingredient.name)) {
                            uniqueIngredients.set(ingredient.name, {
                                id: ingredient.id,
                                name: ingredient.name,
                                recipe_id: recipe.id,
                                recipe_name: recipe.name
                            });
                        }
                    });
                }
            });

            // Sort ingredients alphabetically by name
            const sortedIngredients = Array.from(uniqueIngredients.values())
                .sort((a, b) => a.name.localeCompare(b.name));

            // Update the first option
            select.options[0].text = 'Select an ingredient';

            // Add options for each unique ingredient
            sortedIngredients.forEach(ingredient => {
                const option = document.createElement('option');
                option.value = `${ingredient.recipe_id}:${ingredient.id}`; // Store both recipe ID and ingredient ID
                option.text = `${ingredient.name} (from ${ingredient.recipe_name})`;
                select.appendChild(option);
            });

        } catch (error) {
            console.error('Error loading existing ingredients:', error);
            select.options[0].text = 'Error loading ingredients';
        }
    }

    // Function to fetch ingredient details and populate the form
    async function fetchIngredientDetails(combinedId) {
        // Parse the combined ID (recipeId:ingredientId)
        const [recipeId, ingredientId] = combinedId.split(':');
        if (!recipeId || !ingredientId) {
            console.error('Invalid ingredient ID format');
            return;
        }

        try {
            // Fetch the ingredient details
            const response = await fetch(`/api/recipes/${recipeId}/ingredients/${ingredientId}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const ingredient = await response.json();
            console.log('Fetched ingredient details:', ingredient);

            // Populate the form fields
            document.getElementById('add-ingredient-name').value = ingredient.name;
            document.getElementById('add-ingredient-amount').value = ingredient.amount;
            document.getElementById('add-ingredient-package-amount').value = ingredient.package_amount || '';
            document.getElementById('add-ingredient-price').value = ingredient.price;
            document.getElementById('add-ingredient-calories').value = ingredient.calories;
            document.getElementById('add-ingredient-protein').value = ingredient.protein;
            document.getElementById('add-ingredient-fats').value = ingredient.fats;
            document.getElementById('add-ingredient-carbs').value = ingredient.carbohydrates;

            // Populate additional nutrition fields if available
            if (ingredient.fiber !== undefined) document.getElementById('add-ingredient-fiber').value = ingredient.fiber;
            if (ingredient.starch !== undefined) document.getElementById('add-ingredient-starch').value = ingredient.starch;
            if (ingredient.sugars !== undefined) document.getElementById('add-ingredient-sugars').value = ingredient.sugars;
            if (ingredient.added_sugars !== undefined) document.getElementById('add-ingredient-added-sugars').value = ingredient.added_sugars;
            if (ingredient.net_carbs !== undefined) document.getElementById('add-ingredient-net-carbs').value = ingredient.net_carbs;

            if (ingredient.monounsaturated !== undefined) document.getElementById('add-ingredient-monounsaturated').value = ingredient.monounsaturated;
            if (ingredient.polyunsaturated !== undefined) document.getElementById('add-ingredient-polyunsaturated').value = ingredient.polyunsaturated;
            if (ingredient.omega3 !== undefined) document.getElementById('add-ingredient-omega3').value = ingredient.omega3;
            if (ingredient.omega6 !== undefined) document.getElementById('add-ingredient-omega6').value = ingredient.omega6;
            if (ingredient.saturated !== undefined) document.getElementById('add-ingredient-saturated').value = ingredient.saturated;
            if (ingredient.trans_fat !== undefined) document.getElementById('add-ingredient-trans-fat').value = ingredient.trans_fat;
            if (ingredient.cholesterol !== undefined) document.getElementById('add-ingredient-cholesterol').value = ingredient.cholesterol;

            // Populate other nutrition fields as needed

        } catch (error) {
            console.error('Error fetching ingredient details:', error);
            const statusElement = document.querySelector('.add-ingredient-status');
            if (statusElement) {
                showStatus(statusElement, `Error loading ingredient details: ${error.message}`, 'error');
            }
        }
    }

    // Function to handle adding a new ingredient to a recipe
    async function handleAddIngredientSubmit(event) {
        event.preventDefault();

        console.log('=== handleAddIngredientSubmit called ===');

        const form = event.target;
        const recipeId = document.getElementById('add-ingredient-recipe-id').value;
        const statusElement = document.querySelector('.add-ingredient-status');

        console.log('Form submitted for recipe ID:', recipeId);

        if (!recipeId) {
            console.error('Recipe ID is missing');
            showStatus(statusElement, 'Recipe ID is missing', 'error');
            return;
        }

        showStatus(statusElement, 'Adding ingredient...', 'info');

        try {
            // Log all form fields for debugging
            console.log('Form fields:');
            const formFields = form.querySelectorAll('input, select, textarea');
            formFields.forEach(field => {
                console.log(`- ${field.id || 'unnamed field'}: ${field.value}`);
            });

            // Gather form data
            const nameInput = document.getElementById('add-ingredient-name');
            const amountInput = document.getElementById('add-ingredient-amount');
            const packageAmountInput = document.getElementById('add-ingredient-package-amount');
            const priceInput = document.getElementById('add-ingredient-price');

            if (!nameInput || !amountInput || !priceInput) {
                console.error('Required form fields are missing');
                showStatus(statusElement, 'Required form fields are missing', 'error');
                return;
            }

            const name = nameInput.value.trim();
            const amount = amountInput.value ? parseFloat(amountInput.value) : null;
            const packageAmount = packageAmountInput && packageAmountInput.value ?
                parseFloat(packageAmountInput.value) : null;
            const price = priceInput.value ? parseFloat(priceInput.value) : null;

            // Validate required fields
            if (!name) {
                console.error('Ingredient name is required');
                showStatus(statusElement, 'Ingredient name is required', 'error');
                return;
            }

            if (amount === null || isNaN(amount) || amount <= 0) {
                console.error('Invalid amount value:', amount);
                showStatus(statusElement, 'Amount must be a positive number', 'error');
                return;
            }

            if (price === null || isNaN(price) || price < 0) {
                console.error('Invalid price value:', price);
                showStatus(statusElement, 'Price must be a non-negative number', 'error');
                return;
            }

            const ingredientData = {
                name: name,
                amount: amount,
                package_amount: packageAmount,
                price: price
            };

            // Get values from either the form fields or the Cronometer parsed data
            const getValueFromFormOrCronometer = (fieldId, cronometerClass) => {
                const formElement = document.getElementById(fieldId);
                const cronometerElement = form.querySelector(cronometerClass);

                console.log(`Getting value for ${fieldId} / ${cronometerClass}`);

                // If the form field has a value, use it
                if (formElement && formElement.value) {
                    console.log(`- Found value in form field: ${formElement.value}`);
                    return parseFloat(formElement.value);
                }
                // Otherwise, check if there's a value from Cronometer
                else if (cronometerElement && cronometerElement.value) {
                    console.log(`- Found value in Cronometer element: ${cronometerElement.value}`);
                    return parseFloat(cronometerElement.value);
                }
                // Default to 0 for required fields
                console.log(`- No value found, defaulting to 0`);
                return 0;
            };

            // Add required nutrition fields
            ingredientData.calories = getValueFromFormOrCronometer('add-ingredient-calories', '.ingredient-calories');
            ingredientData.protein = getValueFromFormOrCronometer('add-ingredient-protein', '.ingredient-protein');
            ingredientData.fats = getValueFromFormOrCronometer('add-ingredient-fats', '.ingredient-fat');
            ingredientData.carbohydrates = getValueFromFormOrCronometer('add-ingredient-carbs', '.ingredient-carbs');

            // Debug log to check values
            console.log('Required nutrition fields:');
            console.log('- calories:', ingredientData.calories);
            console.log('- protein:', ingredientData.protein);
            console.log('- fats:', ingredientData.fats);
            console.log('- carbohydrates:', ingredientData.carbohydrates);

            // Add optional nutrition fields if they have values
            const optionalFields = [
                'fiber', 'starch', 'sugars', 'added_sugars', 'net_carbs',
                'monounsaturated', 'polyunsaturated', 'omega3', 'omega6', 'saturated', 'trans_fat', 'cholesterol',
                'alcohol', 'caffeine', 'water',
                'vitamin_b1', 'vitamin_b2', 'vitamin_b3', 'vitamin_b5', 'vitamin_b6', 'vitamin_b12',
                'folate', 'vitamin_a', 'vitamin_c', 'vitamin_d', 'vitamin_e', 'vitamin_k',
                'calcium', 'copper', 'iron', 'magnesium', 'manganese', 'phosphorus', 'potassium', 'selenium', 'sodium', 'zinc',
                'cystine', 'histidine', 'isoleucine', 'leucine', 'lysine', 'methionine', 'phenylalanine', 'threonine', 'tryptophan', 'tyrosine', 'valine'
            ];

            // First check for values in the form fields
            optionalFields.forEach(field => {
                const element = document.getElementById(`add-ingredient-${field}`);
                if (element && element.value) {
                    ingredientData[field] = parseFloat(element.value);
                }
            });

            // Check for complete nutrition data from Cronometer parser
            if (form.dataset.completeNutritionData) {
                try {
                    const nutritionData = JSON.parse(form.dataset.completeNutritionData);
                    console.log('Found complete nutrition data:', nutritionData);

                    // Map Cronometer data to our database fields
                    const fieldMappings = {
                        calories: 'calories',
                        protein: 'protein',
                        fat: 'fats',
                        carbs: 'carbohydrates',
                        fiber: 'fiber',
                        starch: 'starch',
                        sugars: 'sugars',
                        addedSugars: 'added_sugars',
                        netCarbs: 'net_carbs',
                        saturated: 'saturated',
                        monounsaturated: 'monounsaturated',
                        polyunsaturated: 'polyunsaturated',
                        omega3: 'omega3',
                        omega6: 'omega6',
                        transFat: 'trans_fat',
                        cholesterol: 'cholesterol',
                        alcohol: 'alcohol',
                        caffeine: 'caffeine',
                        water: 'water',
                        thiamine: 'thiamine',
                        riboflavin: 'riboflavin',
                        niacin: 'niacin',
                        vitaminB6: 'vitamin_b6',
                        folate: 'folate',
                        vitaminB12: 'vitamin_b12',
                        pantothenic: 'pantothenic_acid',
                        biotin: 'biotin',
                        vitaminA: 'vitamin_a',
                        vitaminC: 'vitamin_c',
                        vitaminD: 'vitamin_d',
                        vitaminE: 'vitamin_e',
                        vitaminK: 'vitamin_k',
                        calcium: 'calcium',
                        copper: 'copper',
                        iron: 'iron',
                        magnesium: 'magnesium',
                        manganese: 'manganese',
                        phosphorus: 'phosphorus',
                        potassium: 'potassium',
                        selenium: 'selenium',
                        sodium: 'sodium',
                        zinc: 'zinc',
                        histidine: 'histidine',
                        isoleucine: 'isoleucine',
                        leucine: 'leucine',
                        lysine: 'lysine',
                        methionine: 'methionine',
                        phenylalanine: 'phenylalanine',
                        threonine: 'threonine',
                        tryptophan: 'tryptophan',
                        valine: 'valine',
                        tyrosine: 'tyrosine',
                        cystine: 'cystine'
                    };

                    // Add all nutrition data to the ingredient data
                    for (const [cronometerKey, dbKey] of Object.entries(fieldMappings)) {
                        // Skip if we already have this field from the form
                        if (ingredientData[dbKey] !== undefined) {
                            continue;
                        }

                        // Add the value if it exists in the nutrition data
                        if (nutritionData[cronometerKey] !== undefined && nutritionData[cronometerKey] !== null) {
                            ingredientData[dbKey] = parseFloat(nutritionData[cronometerKey]);
                        }
                    }
                } catch (error) {
                    console.error('Error parsing complete nutrition data:', error);
                }
            }

            // Then check for any other values in data attributes
            const dataAttributes = form.dataset;
            for (const key in dataAttributes) {
                // Skip the complete nutrition data
                if (key === 'completeNutritionData' || key === 'dbFormatNutritionData' || key === 'micronutrientHandlerAdded' || key === 'cronometerParserInitialized') {
                    continue;
                }

                // Convert camelCase to snake_case for database compatibility
                const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);

                // Skip if we already have this field from the form or nutrition data
                if (ingredientData[snakeKey] !== undefined) {
                    continue;
                }

                // Add the value from the data attribute
                if (dataAttributes[key] && !isNaN(parseFloat(dataAttributes[key]))) {
                    ingredientData[snakeKey] = parseFloat(dataAttributes[key]);
                }
            }

            // Final validation check for required fields
            if (!ingredientData.calories || !ingredientData.protein || !ingredientData.fats || !ingredientData.carbohydrates) {
                console.error('Missing required nutritional values:', ingredientData);
                showStatus(statusElement, 'Missing required nutritional values (calories, protein, fats, carbs)', 'error');
                return;
            }

            console.log('Sending ingredient data to server:', JSON.stringify(ingredientData, null, 2));

            // Send the data to the server with better error handling
            let response;
            try {
                response = await fetch(`/api/recipes/${recipeId}/ingredients`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache, no-store, must-revalidate'
                    },
                    body: JSON.stringify(ingredientData)
                });

                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);

                if (!response.ok) {
                    let errorMessage = `Server returned ${response.status} ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorMessage;
                        console.error('Server error response:', errorData);
                    } catch (jsonError) {
                        console.error('Could not parse error response as JSON:', jsonError);
                    }
                    throw new Error(errorMessage);
                }
            } catch (fetchError) {
                console.error('Fetch error:', fetchError);
                showStatus(statusElement, `Network error: ${fetchError.message}`, 'error');
                return;
            }

            // Parse the response
            let result;
            try {
                result = await response.json();
                console.log('Ingredient added successfully. Server response:', result);

                // Verify the ingredient was added
                if (result.ingredients && result.ingredients.length > 0) {
                    const lastIngredient = result.ingredients[result.ingredients.length - 1];
                    console.log('Last ingredient in recipe:', lastIngredient);
                } else {
                    console.warn('No ingredients returned in response');
                }
            } catch (jsonError) {
                console.error('Error parsing response JSON:', jsonError);
                showStatus(statusElement, 'Error parsing server response', 'error');
                return;
            }

            // Show success message
            showStatus(statusElement, 'Ingredient added successfully!', 'success');

            // Hide the form after a short delay and refresh the ingredient list
            setTimeout(() => {
                const addIngredientForm = document.querySelector('.add-ingredient-form');
                if (addIngredientForm) {
                    addIngredientForm.style.display = 'none';
                    console.log('Hid the add ingredient form');
                } else {
                    console.warn('Could not find add ingredient form to hide');
                }

                // Refresh the ingredient list
                const recipeCard = document.querySelector(`.recipe-card[data-id="${recipeId}"]`);
                if (recipeCard) {
                    const detailsDiv = recipeCard.querySelector('.ingredient-details');
                    if (detailsDiv) {
                        // Set a flag to force refresh even if already visible
                        detailsDiv.dataset.forceRefresh = 'true';
                        console.log(`Refreshing ingredients for recipe ${recipeId}`);

                        // CRITICAL FIX: Force a complete refresh by closing and reopening the details
                        // This ensures the ingredient list is completely refreshed
                        if (detailsDiv.style.display === 'block') {
                            // First hide the details
                            detailsDiv.style.display = 'none';

                            // Then wait a moment and show them again with a fresh fetch
                            setTimeout(() => {
                                console.log('Performing forced refresh of ingredient details');
                                fetchAndDisplayIngredients(recipeId, detailsDiv, null, true);
                            }, 300);
                        } else {
                            // If details are already hidden, just fetch with force refresh
                            fetchAndDisplayIngredients(recipeId, detailsDiv, null, true);
                        }
                    } else {
                        console.warn('Could not find ingredient details div to refresh');
                    }
                } else {
                    console.warn(`Could not find recipe card with ID ${recipeId} to refresh`);
                }
            }, 1000);

        } catch (error) {
            console.error('Error adding ingredient:', error);
            showStatus(statusElement, `Error adding ingredient: ${error.message}`, 'error');
        }
    }

    // Helper function to populate the edit form with ingredient data
    window.populateEditForm = function(ingredient) {
        // Basic information
        document.getElementById('edit-ingredient-name').value = ingredient.name || '';
        document.getElementById('edit-ingredient-amount').value = ingredient.amount || '';

        // Handle package_amount specially
        console.debug('Package amount from API:', ingredient.package_amount, typeof ingredient.package_amount);

        // First check if we have a value in local storage
        let packageAmountForForm = '';

        if (window.localStorageManager) {
            const savedPackageAmount = window.localStorageManager.getPackageAmount(ingredient.id);
            if (savedPackageAmount !== null) {
                console.debug(`Found saved package amount in local storage for ingredient ${ingredient.id}: ${savedPackageAmount}`);
                packageAmountForForm = savedPackageAmount;
            } else if (ingredient.package_amount !== null && ingredient.package_amount !== undefined) {
                // Always convert to number
                packageAmountForForm = Number(ingredient.package_amount);

                // If conversion failed, set to empty string
                if (isNaN(packageAmountForForm)) {
                    packageAmountForForm = '';
                }
            }
        } else if (ingredient.package_amount !== null && ingredient.package_amount !== undefined) {
            // Always convert to number
            packageAmountForForm = Number(ingredient.package_amount);

            // If conversion failed, set to empty string
            if (isNaN(packageAmountForForm)) {
                packageAmountForForm = '';
            }
        }

        document.getElementById('edit-ingredient-package-amount').value = packageAmountForForm;
        console.debug('Package amount set in form:', packageAmountForForm);

        // Store the current package amount in a global variable for reference
        window._currentPackageAmount = packageAmountForForm;
        document.getElementById('edit-ingredient-price').value = ingredient.price || '';

        // General section
        document.getElementById('edit-ingredient-calories').value = ingredient.calories || '';
        document.getElementById('edit-ingredient-alcohol').value = ingredient.alcohol || '';
        document.getElementById('edit-ingredient-caffeine').value = ingredient.caffeine || '';
        document.getElementById('edit-ingredient-water').value = ingredient.water || '';

        // Carbohydrates section
        document.getElementById('edit-ingredient-carbs').value = ingredient.carbohydrates || '';
        document.getElementById('edit-ingredient-fiber').value = ingredient.fiber || '';
        document.getElementById('edit-ingredient-starch').value = ingredient.starch || '';
        document.getElementById('edit-ingredient-sugars').value = ingredient.sugars || '';
        document.getElementById('edit-ingredient-added-sugars').value = ingredient.added_sugars || '';
        document.getElementById('edit-ingredient-net-carbs').value = ingredient.net_carbs || '';

        // Lipids section
        document.getElementById('edit-ingredient-fats').value = ingredient.fats || '';
        document.getElementById('edit-ingredient-monounsaturated').value = ingredient.monounsaturated || '';
        document.getElementById('edit-ingredient-polyunsaturated').value = ingredient.polyunsaturated || '';

        // CRITICAL FIX: Handle both omega3/omega6 and omega_3/omega_6 naming conventions
        const omega3Value = ingredient.omega3 !== undefined ? ingredient.omega3 :
                           (ingredient.omega_3 !== undefined ? ingredient.omega_3 : '');
        document.getElementById('edit-ingredient-omega3').value = omega3Value;
        console.log(`Setting omega3 input value to ${omega3Value} (from database: omega3=${ingredient.omega3}, omega_3=${ingredient.omega_3})`);

        const omega6Value = ingredient.omega6 !== undefined ? ingredient.omega6 :
                           (ingredient.omega_6 !== undefined ? ingredient.omega_6 : '');
        document.getElementById('edit-ingredient-omega6').value = omega6Value;
        console.log(`Setting omega6 input value to ${omega6Value} (from database: omega6=${ingredient.omega6}, omega_6=${ingredient.omega_6})`);

        document.getElementById('edit-ingredient-saturated').value = ingredient.saturated || '';
        document.getElementById('edit-ingredient-trans-fat').value = ingredient.trans_fat || '';
        document.getElementById('edit-ingredient-cholesterol').value = ingredient.cholesterol || '';

        // Protein section
        document.getElementById('edit-ingredient-protein').value = ingredient.protein || '';
        document.getElementById('edit-ingredient-cystine').value = ingredient.cystine || '';
        document.getElementById('edit-ingredient-histidine').value = ingredient.histidine || '';
        document.getElementById('edit-ingredient-isoleucine').value = ingredient.isoleucine || '';
        document.getElementById('edit-ingredient-leucine').value = ingredient.leucine || '';
        document.getElementById('edit-ingredient-lysine').value = ingredient.lysine || '';
        document.getElementById('edit-ingredient-methionine').value = ingredient.methionine || '';
        document.getElementById('edit-ingredient-phenylalanine').value = ingredient.phenylalanine || '';
        document.getElementById('edit-ingredient-threonine').value = ingredient.threonine || '';
        document.getElementById('edit-ingredient-tryptophan').value = ingredient.tryptophan || '';
        document.getElementById('edit-ingredient-tyrosine').value = ingredient.tyrosine || '';
        document.getElementById('edit-ingredient-valine').value = ingredient.valine || '';

        // Vitamins section
        document.getElementById('edit-ingredient-vitamin-b1').value = ingredient.vitamin_b1 || '';
        document.getElementById('edit-ingredient-vitamin-b2').value = ingredient.vitamin_b2 || '';
        document.getElementById('edit-ingredient-vitamin-b3').value = ingredient.vitamin_b3 || '';
        document.getElementById('edit-ingredient-vitamin-b5').value = ingredient.vitamin_b5 || '';
        document.getElementById('edit-ingredient-vitamin-b6').value = ingredient.vitamin_b6 || '';
        document.getElementById('edit-ingredient-vitamin-b12').value = ingredient.vitamin_b12 || '';
        document.getElementById('edit-ingredient-folate').value = ingredient.folate || '';
        document.getElementById('edit-ingredient-vitamin-a').value = ingredient.vitamin_a || '';
        document.getElementById('edit-ingredient-vitamin-c').value = ingredient.vitamin_c || '';
        document.getElementById('edit-ingredient-vitamin-d').value = ingredient.vitamin_d || '';
        document.getElementById('edit-ingredient-vitamin-e').value = ingredient.vitamin_e || '';
        document.getElementById('edit-ingredient-vitamin-k').value = ingredient.vitamin_k || '';

        // Minerals section
        document.getElementById('edit-ingredient-calcium').value = ingredient.calcium || '';
        document.getElementById('edit-ingredient-copper').value = ingredient.copper || '';
        document.getElementById('edit-ingredient-iron').value = ingredient.iron || '';
        document.getElementById('edit-ingredient-magnesium').value = ingredient.magnesium || '';
        document.getElementById('edit-ingredient-manganese').value = ingredient.manganese || '';
        document.getElementById('edit-ingredient-phosphorus').value = ingredient.phosphorus || '';
        document.getElementById('edit-ingredient-potassium').value = ingredient.potassium || '';
        document.getElementById('edit-ingredient-selenium').value = ingredient.selenium || '';
        document.getElementById('edit-ingredient-sodium').value = ingredient.sodium || '';
        document.getElementById('edit-ingredient-zinc').value = ingredient.zinc || '';
    };

    // Function to remove an ingredient from a recipe
    window.removeIngredientFromRecipe = async function(recipeId, ingredientId, container) {
        console.log(`Removing ingredient ${ingredientId} from recipe ${recipeId}`);

        if (!recipeId || !ingredientId) {
            console.error('Recipe ID and ingredient ID are required');
            return;
        }

        if (!container) {
            console.error('Container not provided to removeIngredientFromRecipe');
            return;
        }

        // Confirm deletion
        if (!confirm('Are you sure you want to remove this ingredient from the recipe?')) {
            return;
        }

        try {
            // Show loading state
            const statusElement = container.querySelector('.status') || document.createElement('div');
            statusElement.textContent = 'Removing ingredient...';
            statusElement.className = 'status info';

            // Call the API to remove the ingredient
            const response = await fetch(`/api/recipes/${recipeId}/ingredients/${ingredientId}`, {
                method: 'DELETE',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('Error response:', errorText);
                throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
            }

            const result = await response.json();
            console.log('Ingredient removed successfully:', result);

            // Show success message
            statusElement.textContent = 'Ingredient removed successfully!';
            statusElement.className = 'status success';

            // Refresh the ingredient list
            const recipeCard = container.closest('.recipe-card');
            if (recipeCard) {
                const detailsDiv = recipeCard.querySelector('.ingredient-details');
                if (detailsDiv) {
                    // Set a flag to force refresh even if already visible
                    detailsDiv.dataset.forceRefresh = 'true';

                    // Refresh the ingredient list
                    if (typeof fetchAndDisplayIngredients === 'function') {
                        fetchAndDisplayIngredients(recipeId, detailsDiv);
                    } else if (typeof window.fetchAndDisplayIngredients === 'function') {
                        window.fetchAndDisplayIngredients(recipeId, detailsDiv);
                    } else {
                        console.error('fetchAndDisplayIngredients function not found');
                        alert('Error: Could not refresh ingredients (function not available)');
                    }
                }

                // Update the recipe calories display
                const caloriesSpan = recipeCard.querySelector('.recipe-card-calories');
                if (caloriesSpan && result.total_calories !== undefined) {
                    caloriesSpan.textContent = `${result.total_calories.toFixed(1)} calories`;
                }
            }
        } catch (error) {
            console.error('Error removing ingredient:', error);

            // Show error message
            const statusElement = container.querySelector('.status') || document.createElement('div');
            statusElement.textContent = `Error removing ingredient: ${error.message}`;
            statusElement.className = 'status error';
        }
    };

    // Function to toggle nutrition panel in add/edit ingredient forms
    // Expose the function to the global scope so it can be called from onclick
    window.toggleNutritionPanel = function(button) {
        // Check if the button is in the table header or in a form
        const form = button.closest('form') || document.getElementById('add-ingredient-form');
        if (!form) {
            console.error('Could not find form for toggleNutritionPanel');
            return;
        }

        const panel = form.querySelector('.detailed-nutrition-panel');
        if (!panel) {
            console.error('Could not find detailed nutrition panel');
            return;
        }

        const isVisible = panel.style.display === 'block';

        panel.style.display = isVisible ? 'none' : 'block';
        button.textContent = isVisible ? 'Show Detailed Nutrition' : 'Hide Detailed Nutrition';
        button.classList.toggle('active', !isVisible);
    }
});